<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bloxd.io + C√°mara 1ra/3ra persona + Mira + Salto corregido</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
<style>
  body { margin: 0; overflow: hidden;
  font-family: 'Press Start 2P', cursive;touch-action: none; background:#87CEEB; }
  

 #joystick {
  position: absolute; bottom: 30px; left: 30px;
  width: 100px; height: 100px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid #888;
  image-rendering: pixelated;
}

  #joystick > div {
    position: absolute;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.7);
    
    pointer-events: none;
    left: 35px;
    top: 35px;
  }
 #pause-button {
  position: absolute;
  top: 1px;
  left: 50%;
  transform: translateX(-50%);
  width: 30px;
  height: 30px;
  background-color: #222;
  color: #fff;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#shadow-toggle {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  width: 140px;
  height: 40px;
  background-color: #444;
  color: white;
  font-size: 14px;
  text-align: center;
  line-height: 40px;
  
  z-index: 20;
  cursor: pointer;
}
#shadow-toggle.on {
  background-color: #27ae60;
}

#pause-menu {
  position: absolute;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  backdrop-filter: blur(10px);
  background-color: rgba(0,0,0,0.4);
  z-index: 30;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.pause-option {
  width: 160px;
  margin: 10px;
  padding: 12px;
  background: #333;
  color: white;
  font-size: 18px;
  text-align: center;
  border-radius: 8px;
  cursor: pointer;
}

#jump-button {
  position: absolute;
  bottom: 59px;
  right: 50px;
  width: 34px;
  height: 34px;
  background-color: #3c3c3c;
  border: 4px solid #fff;
  box-shadow: inset -4px -4px 0 #1a1a1a, inset 4px 4px 0 #666;
  image-rendering: pixelated;
  cursor: pointer;
  border-radius: 0%;
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#camera-toggle {
position: absolute;
top: 10px;
right: 10px;
width: 50px;
height: 40px;
background-color: #222;
color: #e0e0e0;
font-size: 9px;
font-weight: 600;
text-align: center;
line-height: 40px;

box-shadow: 0 2px 5px rgba(0,0,0,0.4);
user-select: none;
cursor: pointer;
transition: background-color 0.25s ease, color 0.25s ease;
z-index: 10;
}
#camera-toggle\:hover {
background: #666;
color: #fff;
}
#camera-toggle\:active {
background: #444;
color: #ccc;
}

  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    pointer-events: none;
    z-index: 15;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: black;
  }
  #crosshair:before {
    left: 9px;
    top: 0;
    width: 2px;
    height: 20px;
  }
  #crosshair:after {
    top: 9px;
    left: 0;
    width: 20px;
    height: 2px;
  }
  #pri-button {
  position: absolute;
  top: 100px;
  right: 10px;
  width: 64px;
  height: 40px;
  background-color: #800;
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  
  z-index: 10;
  user-select: none;
  touch-action: none;
}

  #slide-panel {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: #222;
  color: white;
  padding: 20px;
  box-shadow: -3px 0 10px rgba(0,0,0,0.7);
  transition: right 0.3s ease;
  z-index: 50;
  display: flex;
  flex-direction: column;
}

#slide-panel.open {
  right: 0;
}

#close-panel-btn {
  align-self: flex-end;
  font-size: 24px;
  cursor: pointer;
  user-select: none;
}
#start-panel {
  position: fixed;
  inset: 0;
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#play-button {
  font-family: 'Press Start 2P', monospace;
  font-size: 16px;
  padding: 16px 32px;
  border: 3px solid #fff;
  background-color: #222;
  color: #0f0;
  cursor: pointer;
  box-shadow: 0 0 5px #0f0;
  image-rendering: pixelated;
  text-shadow: 1px 1px 0 #000;
}

#play-button:active {
  transform: scale(0.95);
}

/* Fuente pixel */
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
</style>
</head>
<body>
  <div id="start-panel">
  <button id="play-button">JUGAR</button>
</div>

<div id="pause-button"><i class="fas fa-pause"></i></div>


<div id="pause-menu">
  <div class="pause-option" id="resume-btn"><i class="fas fa-play"></i> Reanudar</div>
<div id="open-panel-btn" class="pause-option"><i class="fas fa-cog"></i> Ajustes</div>


<div id="slide-panel">
  <div id="close-panel-btn">√ó</div>
  <!-- Contenido del panel -->

    <div id="shadow-toggle">Sombras: OFF</div>
</div>



 

  <div id="settings-menu" style="display:none; flex-direction: column; align-items: center; justify-content: center; height: 100vh; width: 100vw; position: absolute; top: 0; left: 0; backdrop-filter: blur(10px); background-color: rgba(0,0,0,0.4); z-index: 40;">
  <div class="pause-option" id="back-btn">üîô Volver</div>
  <!-- Aqu√≠ luego agregas tus controles de ajustes -->
</div>

</div>

<div id="joystick"><div id="joystick-thumb"></div></div>
<div id="jump-button"></div>
<div id="camera-toggle">3ra </div>
<div id="pri-button">pri</div>

<div id="crosshair"></div>

<script>
// Setup b√°sico
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Funci√≥n para redimensionar correctamente
function resizeCanvas() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
}

// Eventos para detectar rotaci√≥n o cambio de tama√±o
window.addEventListener('resize', resizeCanvas);
screen.orientation?.addEventListener("change", resizeCanvas);
document.addEventListener("fullscreenchange", resizeCanvas);

// Llamar al inicio por si ya est√° en horizontal
resizeCanvas();


document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const cameraHolder = new THREE.Object3D();
scene.add(cameraHolder);
cameraHolder.add(camera);

const loader = new THREE.TextureLoader();
loader.load('Texturas/dia.jpg', function(texture) {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
});

// Luz
scene.background = new THREE.Color(0xffffff);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(10,20,10);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
scene.add(dirLight);

const salto = 1; // altura de salto en bloques
const gravedadBase = 0.02;
const gravedad = gravedadBase * salto;  // mayor salto = m√°s gravedad para mantener tiempos similares

function estaRodeado(bloque) {
  const dirs = [
    new THREE.Vector3(1,0,0),
    new THREE.Vector3(-1,0,0),
    new THREE.Vector3(0,1,0),
    new THREE.Vector3(0,-1,0),
    new THREE.Vector3(0,0,1),
    new THREE.Vector3(0,0,-1)
  ];

  const pos = bloque.position.clone().divideScalar(blockSize);

  return dirs.every(dir => {
    const vecino = terrain.find(b =>
      b.position.x === (pos.x + dir.x) * blockSize &&
      b.position.y === (pos.y + dir.y) * blockSize &&
      b.position.z === (pos.z + dir.z) * blockSize
    );
    return !!vecino;
  });
}

// Terreno b√°sico con bloques
const simplex = new SimplexNoise();
const blockSize = 1;
const worldSize = 16;
let terrain = [];
let joystickTouchId = null;
let cameraTouchId = null;

const textureLoader = new THREE.TextureLoader();

const textures = {
  grass_top: textureLoader.load("Texturas/cesped.jpg"),
  grass_side: textureLoader.load("Texturas/cesped_parte_costado.jpg"),
  dirt: textureLoader.load("Texturas/tierra.jpg"),
  stone: textureLoader.load("Texturas/piedra.jpg"),
  crack: textureLoader.load("Texturas/crack.png") // ‚Üê se a√±adi√≥ aqu√≠
};
const panel = document.getElementById("start-panel");
const button = document.getElementById("play-button");

async function goFullscreenLandscape() {
  try {
    // Fullscreen
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    
    // Orientaci√≥n horizontal
    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientaci√≥n:", e);
  }
  async function goFullscreenLandscape() {
  try {
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();

    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");

    resizeCanvas(); // Asegura que se actualice al instante
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientaci√≥n:", e);
  }

  panel.style.display = "none";
}

  // Ocultar panel
  panel.style.display = "none";
}

// Mostrar el panel si se sali√≥ de fullscreen u orientaci√≥n
function checkState() {
  const isFull = !!document.fullscreenElement;
  const isLandscape = screen.orientation?.type?.includes("landscape");
  
  if (!isFull || !isLandscape) {
    panel.style.display = "flex";
  }
}

button.addEventListener("click", goFullscreenLandscape);
document.addEventListener("fullscreenchange", checkState);
screen.orientation?.addEventListener("change", checkState);

// Tambi√©n se comprueba al rotar el dispositivo
window.addEventListener("resize", checkState);
const jumpButton = document.getElementById("jump-button");

function createBlock(x,y,z,type){
  const pos = new THREE.Vector3(x,y,z);
  const directions = [
    new THREE.Vector3(1,0,0),
    new THREE.Vector3(-1,0,0),
    new THREE.Vector3(0,1,0),
    new THREE.Vector3(0,-1,0),
    new THREE.Vector3(0,0,1),
    new THREE.Vector3(0,0,-1)
  ];
  
  const isSurrounded = directions.every(dir=>{
    const neighborPos = pos.clone().add(dir);
    return terrain.some(b=>
      b.position.x === neighborPos.x * blockSize &&
      b.position.y === neighborPos.y * blockSize &&
      b.position.z === neighborPos.z * blockSize
    );
  });
  if(isSurrounded) return;

  const textureMaps = (() => {
    if(type==="grass"){
      return [
        textures.grass_side,
        textures.grass_side,
        textures.grass_top,
        textures.dirt,
        textures.grass_side,
        textures.grass_side
      ];
    } else if(type==="dirt") {
      return new Array(6).fill(textures.dirt);
    } else if(type==="stone") {
      return new Array(6).fill(textures.stone);
    }
  })();

  const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
  const materials = [];
  for(let i=0; i<6; i++){
    const neighborPos = pos.clone().add(directions[i]);
    const hasNeighbor = terrain.some(b=>
      b.position.x === neighborPos.x * blockSize &&
      b.position.y === neighborPos.y * blockSize &&
      b.position.z === neighborPos.z * blockSize
    );
    materials.push(hasNeighbor ? new THREE.MeshStandardMaterial({visible:false}) : new THREE.MeshStandardMaterial({map:textureMaps[i]}));
  }
  const block = new THREE.Mesh(geometry, materials);
  block.userData = {
  type: type,
  resistance: type === "stone" ? 3 : type === "dirt" ? 1.5 : 1,
  currentBreak: 0,
  crackMaterial: null
};

block.castShadow = true;
block.receiveShadow = true;
block.position.set(x*blockSize,y*blockSize,z*blockSize);
if (!estaRodeado(block)) {
  scene.add(block);
}

terrain.push(block);


}

function generateTerrain(){
  terrain = [];
  for(let x=0;x<worldSize;x++){
    for(let z=0;z<worldSize;z++){
      const n = simplex.noise2D(x/10,z/10);
      const h = Math.floor((n+1)*5);
      for(let y=0;y<h;y++){
        if(y===h-1) createBlock(x,y,z,"grass");
        else if(y>=h-3) createBlock(x,y,z,"dirt");
        else createBlock(x,y,z,"stone");
      }
    }
  }
}

// Jugador cubo rojo
const playerGeometry = new THREE.BoxGeometry(0.8,1,0.8);
const playerMaterial = new THREE.MeshStandardMaterial({color:0x0000ff});
const player = new THREE.Mesh(playerGeometry, playerMaterial);
player.castShadow = true;
player.receiveShadow = true;

scene.add(player);



const raycaster = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);

function getGroundHeight(x,z){
  raycaster.ray.origin.set(x,50,z);
  raycaster.ray.direction.copy(down);
  const hits = raycaster.intersectObjects(terrain);
  if(hits.length>0) return hits[0].point.y;
  return 0;
}

player.position.set(worldSize/2,10,worldSize/2);
player.position.y = getGroundHeight(player.position.x, player.position.z)+0.5;
const pauseBtn = document.getElementById("pause-button");
const pauseMenu = document.getElementById("pause-menu");
const resumeBtn = document.getElementById("resume-btn");

let sombrasActivas = false; // Estado inicial: desactivadas

const shadowToggle = document.getElementById("shadow-toggle");
const updateSombras = () => {
  dirLight.castShadow = sombrasActivas;

  scene.traverse(obj => {
    if (obj.isMesh) {
      obj.castShadow = sombrasActivas;
      obj.receiveShadow = sombrasActivas;
    }
  });

  shadowToggle.textContent = sombrasActivas ? "Sombras: ON" : "Sombras: OFF";
  shadowToggle.classList.toggle("on", sombrasActivas);
};
const openBtn = document.getElementById('open-panel-btn');
const slidePanel = document.getElementById('slide-panel');
const closeBtn = document.getElementById('close-panel-btn');

openBtn.addEventListener('click', () => {
  slidePanel.classList.add('open');
});

closeBtn.addEventListener('click', () => {
  slidePanel.classList.remove('open');
});

// Palanca
shadowToggle.addEventListener("click", () => {
  sombrasActivas = !sombrasActivas;
  updateSombras();
});

// Aplicar sombras al iniciar (est√°n apagadas)
updateSombras();

let paused = false;

pauseBtn.addEventListener("click", () => {
  paused = true;
  pauseMenu.style.display = "flex";
});

resumeBtn.addEventListener("click", () => {
  paused = false;
  pauseMenu.style.display = "none";
});




// Variables para joystick
const joystick = document.getElementById("joystick");
const thumb = joystick.children[0];
let joystickActive = false;
let joystickStart = {x:0,y:0};
let moveVector = new THREE.Vector2(0,0);

joystick.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (joystickTouchId === null) {
      joystickTouchId = touch.identifier;
      joystickActive = true;
      joystickStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId && joystickActive) {
      const deltaX = (touch.clientX - joystickStart.x) / 50;
      const deltaY = (touch.clientY - joystickStart.y) / 50;
      moveVector.set(
        Math.max(-1, Math.min(1, deltaX)),
        Math.max(-1, Math.min(1, deltaY))
      );
      thumb.style.left = 35 + moveVector.x * 30 + "px";
      thumb.style.top  = 35 + moveVector.y * 30 + "px";
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      joystickTouchId = null;
      joystickActive = false;
      moveVector.set(0, 0);
      thumb.style.left = "35px";
      thumb.style.top  = "35px";
      e.preventDefault();
      break;
    }
  }
});

// Variables para control de c√°mara con swipe
let camYaw = 0;
let camPitch = 0;
const camDistance = 5;
let looking = false;
let lookStart = {x:0,y:0};

function isTouchOnJoystick(touch){
  const r = joystick.getBoundingClientRect();
  return (touch.clientX>=r.left && touch.clientX<=r.right && touch.clientY>=r.top && touch.clientY<=r.bottom);
}

renderer.domElement.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (!isTouchOnJoystick(touch) && cameraTouchId === null) {

      cameraTouchId = touch.identifier;
      looking = true;
      lookStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId && looking) {
      if (isTouchOnJoystick(touch)) return;
      const dx = touch.clientX - lookStart.x;
      const dy = touch.clientY - lookStart.y;
      lookStart.x = touch.clientX;
      lookStart.y = touch.clientY;
      camYaw   -= dx * 0.005;
      camPitch -= dy * 0.005;
      const maxP = Math.PI / 2 - 0.1;
      const minP = -maxP;
      camPitch = Math.max(minP, Math.min(maxP, camPitch));
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId) {
      cameraTouchId = null;
      looking = false;
      e.preventDefault();
      break;
    }
  }
});

const jumpSpeed = 0.25;
let velocityY = 0;
let onGround = false;
let jumpPressed = false;


function jump(){
  if(onGround){
    velocityY = jumpSpeed;
    onGround = false;
  }
}
jumpButton.addEventListener("touchstart", e=>{
  e.preventDefault();
  jumpPressed = true;
  jump();
});
jumpButton.addEventListener("touchend", e=>{
  e.preventDefault();
  jumpPressed = false;
});

// C√°mara toggle 1ra/3ra persona
const camToggleBtn = document.getElementById("camera-toggle");
let firstPerson = false;
camToggleBtn.addEventListener("click", () => {
  firstPerson = !firstPerson;
  camToggleBtn.textContent = firstPerson ? "1ra" : "3ra";
  player.visible = !firstPerson;
});

// Funci√≥n animaci√≥n y l√≥gica
const moveSpeed = 0.3;
const priButton = document.getElementById("pri-button");

let breaking = false;
let currentTarget = null;
let breakStartTime = 0;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const intersects = raycaster.intersectObjects(terrain);
  if (intersects.length > 0) {
    currentTarget = intersects[0].object;
    breakStartTime = performance.now();
    breaking = true;
  }
});

priButton.addEventListener("touchend", () => {
  breaking = false;
  if (currentTarget) {
    removeCrackOverlay(currentTarget);
    currentTarget.userData.currentBreak = 0;
    currentTarget = null;
  }
});

function applyCrackOverlay(block, progress) {
  if (!block.material || !block.material.length) return;

  for (let i = 0; i < block.material.length; i++) {
    block.material[i].alphaMap = textures.crack;
    block.material[i].transparent = true;
    block.material[i].opacity = 0.6 + 0.4 * Math.sin(progress * Math.PI);
    block.material[i].needsUpdate = true;
  }
}

function removeCrackOverlay(block) {
  if (!block.material || !block.material.length) return;

  for (let i = 0; i < block.material.length; i++) {
    block.material[i].alphaMap = null;
    block.material[i].opacity = 1;
    block.material[i].transparent = false;
    block.material[i].needsUpdate = true;
  }
}
const maxBreakDistance = 6;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const intersects = raycaster.intersectObjects(terrain);
  if (intersects.length > 0) {
    const target = intersects[0].object;
    const distance = camera.position.distanceTo(target.position);
    if (distance <= maxBreakDistance) {
      currentTarget = target;
      breakStartTime = performance.now();
      breaking = true;
    }
  }
});

function animate() {
  requestAnimationFrame(animate);
const enableStepUp = false;

  // Movimiento relativo a la c√°mara
  if (moveVector.lengthSq() > 0.01) {
  const camDir = new THREE.Vector3();
  camera.getWorldDirection(camDir);
  camDir.y = 0;
  camDir.normalize();

  const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

  const moveDir = new THREE.Vector3();
  moveDir.addScaledVector(camDir, -moveVector.y);
  moveDir.addScaledVector(camRight, moveVector.x);
  moveDir.normalize();

  const moveStep = moveDir.clone().multiplyScalar(moveSpeed);
  const nextPos = player.position.clone().add(moveStep);

  const playerRadius = 0.3;
  const playerHeight = 1.5;
  const stepHeight = 0.1;
  let canMove = true;

  // Verificamos 3 puntos en vertical: pies, centro y cabeza
  const yOffsets = [0, playerHeight / 2, playerHeight - 0.1];

  for (let yOffset of yOffsets) {
    const pos = nextPos.clone();
    pos.y += yOffset;

    const offsets = [
      new THREE.Vector2(0, 0),
      new THREE.Vector2(playerRadius, 0),
      new THREE.Vector2(-playerRadius, 0),
      new THREE.Vector2(0, playerRadius),
      new THREE.Vector2(0, -playerRadius)
    ];

    for (let offset of offsets) {
      const testX = pos.x + offset.x;
      const testZ = pos.z + offset.y;
      const groundY = getGroundHeight(testX, testZ);

      if (pos.y < groundY + 0.5) {
        canMove = false;
        break;
      }
    }

    if (!canMove) break;
  }

  if (canMove) {
    player.position.copy(nextPos);
  } else if (enableStepUp) {
  // (resto del c√≥digo sin cambios)


    // Intentar peque√±o "step up" para esquinas (como en Minecraft)
    const stepPos = nextPos.clone();
    stepPos.y += stepHeight;

    let stepCanMove = true;
    for (let yOffset of yOffsets) {
      const pos = stepPos.clone();
      pos.y += yOffset;

      for (let offset of [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ]) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.5) {
          stepCanMove = false;
          break;
        }
      }

      if (!stepCanMove) break;
    }

    if (stepCanMove) {
      player.position.copy(stepPos);
    }
  }
}
if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const distance = camera.position.distanceTo(currentTarget.position);
  if (distance > maxBreakDistance) {
    // Se alej√≥ demasiado, cancelar romper
    breaking = false;
    removeCrackOverlay(currentTarget);
    currentTarget.userData.currentBreak = 0;
    currentTarget = null;
  } else {
    const delta = 0.016;
    const data = currentTarget.userData;
    data.currentBreak += delta;

    const progress = data.currentBreak / data.resistance;
    applyCrackOverlay(currentTarget, progress);

    if (data.currentBreak >= data.resistance) {
      scene.remove(currentTarget);
      const idx = terrain.indexOf(currentTarget);
      if (idx !== -1) terrain.splice(idx, 1);
      currentTarget = null;
      breaking = false;
    }
  }
}

  // Gravedad y salto
  const groundCheckOffsets = [
  new THREE.Vector2(0, 0),
  new THREE.Vector2(0.3, 0),
  new THREE.Vector2(-0.3, 0),
  new THREE.Vector2(0, 0.3),
  new THREE.Vector2(0, -0.3)
];

let ground = -Infinity;
for (let offset of groundCheckOffsets) {
  const gx = player.position.x + offset.x;
  const gz = player.position.z + offset.y;
  const h = getGroundHeight(gx, gz);
  if (h > ground) ground = h;
}

  const jumpMax = ground + 0.5 + salto;

  if ((player.position.y < jumpMax && velocityY > 0) || player.position.y > ground + 0.5) {
    velocityY -= gravedad;
    onGround = false;
  } else {
    if (player.position.y >= jumpMax) {
      velocityY = Math.min(velocityY, 0);
      player.position.y = jumpMax;
    } else {
      velocityY = 0;
      player.position.y = ground + 0.5;
      onGround = true;
    }
  }

  player.position.y += velocityY;

  if (firstPerson) {
  const eyeOffset = new THREE.Vector3(0, 0.4, 0); // altura de los ojos
  const camOffset = eyeOffset.clone();

  // Aplicar rotaci√≥n de la c√°mara manualmente
  const quat = new THREE.Quaternion()
    .setFromEuler(new THREE.Euler(camPitch, camYaw, 0, 'YXZ'));
  camOffset.applyQuaternion(quat);

  camera.position.copy(player.position).add(camOffset);
  camera.rotation.set(camPitch, camYaw, 0, 'YXZ');
}
 else {
    // C√°mara detr√°s del jugador
    const offset = new THREE.Vector3(0, 1.5, camDistance);
    offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), camPitch);
    offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), camYaw);

    const camPos = player.position.clone().add(offset);
    camera.position.lerp(camPos, 0.2);

    const target = player.position.clone();
    target.y += 1;
    camera.lookAt(target);

    // Girar jugador con la c√°mara
    player.rotation.y = camYaw;
  }
if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const delta = 0.016;
  const data = currentTarget.userData;
  data.currentBreak += delta;

  const progress = data.currentBreak / data.resistance;
  applyCrackOverlay(currentTarget, progress);

  if (data.currentBreak >= data.resistance) {
  scene.remove(currentTarget);
  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);

  actualizarVecinos(currentTarget); // ‚Üê ACTUALIZA los vecinos

  currentTarget = null;
  breaking = false;
}

}

  renderer.render(scene, camera);
}

generateTerrain();
animate();
function actualizarVecinos(bloqueRoto) {
  const dirs = [
    new THREE.Vector3(1,0,0),
    new THREE.Vector3(-1,0,0),
    new THREE.Vector3(0,1,0),
    new THREE.Vector3(0,-1,0),
    new THREE.Vector3(0,0,1),
    new THREE.Vector3(0,0,-1)
  ];

  const pos = bloqueRoto.position.clone().divideScalar(blockSize);

  for (let i = 0; i < dirs.length; i++) {
    const vecinoPos = pos.clone().add(dirs[i]);

    const vecino = terrain.find(b =>
      b.position.x === vecinoPos.x * blockSize &&
      b.position.y === vecinoPos.y * blockSize &&
      b.position.z === vecinoPos.z * blockSize
    );

    if (!vecino) continue;

    const tipo = vecino.userData.type;
    const texturas = (() => {
      if(tipo==="grass"){
        return [
          textures.grass_side,
          textures.grass_side,
          textures.grass_top,
          textures.dirt,
          textures.grass_side,
          textures.grass_side
        ];
      } else if(tipo==="dirt") {
        return new Array(6).fill(textures.dirt);
      } else if(tipo==="stone") {
        return new Array(6).fill(textures.stone);
      }
    })();

    const nuevaGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
    const nuevaMat = [];

    for (let j = 0; j < 6; j++) {
      const dir = dirs[j];
      const vecinoDeVecino = pos.clone().add(dirs[j]);

      const bloqueOcultando = terrain.find(b =>
        b !== vecino &&
        b.position.x === vecino.position.x + dir.x * blockSize &&
        b.position.y === vecino.position.y + dir.y * blockSize &&
        b.position.z === vecino.position.z + dir.z * blockSize
      );

      nuevaMat.push(
        bloqueOcultando
          ? new THREE.MeshStandardMaterial({ visible: false })
          : new THREE.MeshStandardMaterial({ map: texturas[j] })
      );
    }

    vecino.geometry.dispose();
    vecino.geometry = nuevaGeo;
    vecino.material.forEach(m => m.dispose());
    vecino.material = nuevaMat;
    if (!scene.children.includes(vecino) && !estaRodeado(vecino)) {
  scene.add(vecino);
}

  }
}

</script>

</body>
</html>
