<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>cubox</title>
<link rel="stylesheet" href="libs/press-start.tff">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

  <!-- three.js local -->
  <script src="libs/three.min.js"></script>

  <!-- simplex-noise local -->
  <script src="libs/simplex-noise.min.js"></script>


<style>
    @font-face {
      font-family: 'Press Start 2P';
      src: url('libs/press-start-2p.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    body {
  margin: 0;
  overflow: hidden;
  font-family: 'Press Start 2P', cursive, sans-serif;
  touch-action: none;
  background: #87CEEB;
}
 #joystick {
  position: absolute; bottom: 30px; left: 30px;
  width: 100px; height: 100px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid #888;
  image-rendering: pixelated;
}

  #joystick > div {
    position: absolute;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.7);
    
    pointer-events: none;
    left: 35px;
    top: 35px;
  }
 #pause-button {
  position: absolute;
  top: 1px;
  left: 50%;
  transform: translateX(-50%);
  width: 30px;
  height: 30px;
  background-color: #222;
  color: #fff;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#shadow-toggle {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  width: 140px;
  height: 40px;
  background-color: #444;
  color: white;
  font-size: 14px;
  text-align: center;
  line-height: 40px;
  
  z-index: 20;
  cursor: pointer;
}
#shadow-toggle.on {
  background-color: #27ae60;
}

#pause-menu {
  position: absolute;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  backdrop-filter: blur(10px);
  background-color: rgba(0,0,0,0.4);
  z-index: 30;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.pause-option {
  width: 160px;
  margin: 10px;
  padding: 12px;
  background: #333;
  color: white;
  font-size: 18px;
  text-align: center;
  
  cursor: pointer;
}
#collision-toggle.on {
  background-color: #27ae60 !important;
}

#jump-button {
  position: absolute;
  bottom: 59px;
  right: 50px;
  width: 34px;
  height: 34px;
  background-color: #3c3c3c;
  border: 4px solid #fff;
  box-shadow: inset -4px -4px 0 #1a1a1a, inset 4px 4px 0 #666;
  image-rendering: pixelated;
  cursor: pointer;
  border-radius: 0%;
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#camera-toggle {
position: absolute;
  top: 0px;
  right: 0px;
  font-size: 10px;
  width: 54px;
  height: 35px;
  background-color: rgba(100, 100, 100, 0.5); /* gris translúcido */
  border: 2px solid white; /* borde blanco */
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  z-index: 10;
  user-select: none;
  touch-action: none;
}

box-shadow: 0 2px 5px rgba(0,0,0,0.4);
user-select: none;
cursor: pointer;
transition: background-color 0.25s ease, color 0.25s ease;
z-index: 10;
}
#camera-toggle\:hover {
background: #666;
color: #fff;
}
#camera-toggle\:active {
background: #444;
color: #ccc;
}

  #crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin-left: -10px;
  margin-top: -10px;
  pointer-events: none;
  z-index: 15;
}
#crosshair:before, #crosshair:after {
  content: '';
  position: absolute;
  background: rgba(0, 0, 0, 0.5); /* negro semi-transparente */
}
#crosshair:before {
  left: 9px;
  top: 0;
  width: 2px;
  height: 20px;
}
#crosshair:after {
  top: 9px;
  left: 0;
  width: 20px;
  height: 2px;
}
.pause-option.on {
  background-color: #4caf50;
  color: white;
}

 #pri-button {
  position: absolute;
  top: 100px;
  right: 10px;
  width: 64px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.5); /* gris translúcido */
  border: 2px solid white; /* borde blanco */
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  z-index: 10;
  user-select: none;
  touch-action: none;
}

  #slide-panel {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: #222;
  color: white;
  padding: 20px;
  box-shadow: -3px 0 10px rgba(0,0,0,0.7);
  transition: right 0.3s ease;
  z-index: 50;
  display: flex;
  flex-direction: column;
}

#slide-panel.open {
  right: 0;
}

#close-panel-btn {
  align-self: flex-end;
  font-size: 24px;
  cursor: pointer;
  user-select: none;
}
#start-panel {
  position: fixed;
  inset: 0;
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#play-button {
  font-family: 'Press Start 2P', monospace;
  font-size: 16px;
  padding: 16px 32px;
  border: 3px solid #fff;
  background-color: #222;
  color: #0f0;
  cursor: pointer;
  box-shadow: 0 0 5px #0f0;
  image-rendering: pixelated;
  text-shadow: 1px 1px 0 #000;
}

#play-button:active {
  transform: scale(0.95);
}
#pantalla-carga {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.bloque-contenedor {
  display: flex;
  gap: 20px;
  animation: rotar 2s infinite ease-in-out;
}

.bloque {
  width: 64px;
  height: 64px;
  background-size: cover;
  border: 2px solid white;
}

.bloque.tierra  { background-image: url('Texturas/interiordetronco.png'); }
.bloque.cesped  { background-image: url('Texturas/cesped_parte_costado.jpg'); }
.bloque.piedra  { background-image: url('Texturas/piedra.jpg'); }

#texto-carga {
  margin-top: 40px;
  color: white;
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
}

@keyframes rotar {
  0% { transform: rotate(0deg); }
  50% { transform: rotate(3deg); }
  100% { transform: rotate(-3deg); }
}

/* Fuente pixel */
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
</style>
</head>
<body>
  <div id="pantalla-carga">
  <div class="bloque-contenedor">
    <div class="bloque tierra"></div>
    <div class="bloque cesped"></div>
    <div class="bloque piedra"></div>
  </div>
  <div id="texto-carga">cargando</div>
  <div id="tip-carga" style="margin-top: 20px; color: #ccc; font-size: 10px; font-family: 'Press Start 2P', monospace; text-align: center; max-width: 90%; line-height: 1.5; cursor: pointer;">
   si esto no cambias,significa que no carga.
</div>

</div>

  <div id="start-panel">
  <button id="play-button">JUGAR</button>
</div>
<div id="break-bar-container" style="position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 5px; border: 2px solid white; display: none;">
  <div id="break-bar" style="background: white; width: 0%; height: 100%;"></div>
</div>

<div id="pause-button"><i class="fas fa-pause"></i></div>


<div id="pause-menu">
  <div class="pause-option" id="resume-btn"><i class="fas fa-play"></i> Reanudar</div>
<div id="open-panel-btn" class="pause-option"><i class="fas fa-cog"></i> Ajustes</div>


<div id="slide-panel">
  <div id="close-panel-btn">×</div>
  <!-- Contenido del panel -->
<div style="margin-top: 200px;">
  <label for="render-distance-slider" style="display: block; font-size: 14px;">Distancia de renderizado: <span id="render-distance-value">1</span></label>
  <input type="range" id="render-distance-slider" min="1" max="10" value="1" step="1" style="width: 100%;">
</div>
<div id="spectator-toggle" class="pause-option" style="position: absolute;font-size: 10px; top: 300px; left: 50%; transform: translateX(-50%); width: 200px;">Espectador: OFF</div>
<div style="margin-top: 90px;">
  <label for="render-down-slider" style="display: block; font-size: 14px;">
    Altura visible hacia abajo: <span id="render-down-value">5</span>
  </label>
  <input type="range" id="render-down-slider" min="1" max="64" value="5" step="1" style="width: 100%;">
</div>


    <div id="shadow-toggle">Sombras: OFF</div>
</div>



 

  <div id="settings-menu" style="display:none; flex-direction: column; align-items: center; justify-content: center; height: 100vh; width: 100vw; position: absolute; top: 0; left: 0; backdrop-filter: blur(10px); background-color: rgba(0,0,0,0.4); z-index: 40;">
  <div class="pause-option" id="back-btn">🔙 Volver</div>
  <!-- Aquí luego agregas tus controles de ajustes -->
</div>

</div>

<div id="joystick"><div id="joystick-thumb"></div></div>
<div id="jump-button"></div>
<div id="camera-toggle">1ra </div>
<div id="pri-button">pri</div>

<div id="crosshair"></div>

<script>
// Setup básico
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Función para redimensionar correctamente
function resizeCanvas() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
}

// Eventos para detectar rotación o cambio de tamaño
window.addEventListener('resize', resizeCanvas);
screen.orientation?.addEventListener("change", resizeCanvas);
document.addEventListener("fullscreenchange", resizeCanvas);

// Llamar al inicio por si ya está en horizontal
resizeCanvas();


document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const cameraHolder = new THREE.Object3D();
scene.add(cameraHolder);
cameraHolder.add(camera);

const loader = new THREE.TextureLoader();
loader.load('Texturas/dia.jpg', function(texture) {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
});

// Luz
scene.background = new THREE.Color(0xff6600);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(10,20,10);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
scene.add(dirLight);
const renderDistanceSlider = document.getElementById("render-distance-slider");
const renderDistanceValue = document.getElementById("render-distance-value");

renderDistanceSlider.addEventListener("input", () => {
  RENDER_DISTANCE = parseInt(renderDistanceSlider.value);
  renderDistanceValue.textContent = RENDER_DISTANCE;
  updateChunksAroundPlayer(); // fuerza una actualización inmediata
});
let crackOverlayInstanceMesh = null;

let modoEspectador = false;
let bajando = false;
let dobleToqueTiempo = 0;

const salto = 1; // altura de salto en bloques
const gravedadBase = 0.02;
const gravedad = gravedadBase * salto;  // mayor salto = más gravedad para mantener tiempos similares

const texturaGrieta = loader.load('/Texturas/crack.png');
texturaGrieta.wrapS = THREE.RepeatWrapping;
texturaGrieta.wrapT = THREE.RepeatWrapping;


// Terreno básico con bloques
const simplex = new SimplexNoise();
const blockSize = 1;
const worldSize = 10;
let terrain = [];
let joystickTouchId = null;
let cameraTouchId = null;
const blockTypes = ["grass", "dirt", "stone"];
const MAX_INSTANCES_PER_TYPE = 500; // ajustable por chunk
const GEOMETRY_CUBO = new THREE.BoxGeometry(1, 1, 1);
let crackBreaking = false;
let crackStartTime = 0;
let crackInstanceId = null;
let crackInstancedMesh = null;

const crackBreakProgress = {};
const crackResistances = new Map(); // key = "cx,cz|lx,ly,lz", value = resistencia

const crackOverlayObj = new THREE.Mesh(
  new THREE.BoxGeometry(1.01, 1.01, 1.01),
  new THREE.MeshBasicMaterial({
    map: null, // se actualizará
    transparent: true,
    depthTest: true,
    depthWrite: false,
  })
);
crackOverlayObj.renderOrder = 999;
crackOverlayObj.visible = false;
scene.add(crackOverlayObj);

const textureLoader = new THREE.TextureLoader();
const atlasTexture = textureLoader.load("Texturas/atlas.png");
atlasTexture.magFilter = THREE.NearestFilter;
atlasTexture.minFilter = THREE.NearestFilter;

const atlasMaterial = new THREE.MeshStandardMaterial({ map: atlasTexture });
const geometries = {
  grass: createBlockGeometryFromAtlas([2, 2, 0, 3, 2, 2]), // lados, arriba, abajo
  dirt:  createBlockGeometryFromAtlas([3, 3, 3, 3, 3, 3]),
  stone: createBlockGeometryFromAtlas([1, 1, 1, 1, 1, 1]),
  bedrock: createBlockGeometryFromAtlas([4, 4, 4, 4, 4, 4]) // nueva geometría para bedrock
};


const texturesCrack = [
  textureLoader.load('Texturas/crack1.png'),
  textureLoader.load('Texturas/crack2.png'),
  textureLoader.load('Texturas/crack3.png'),
  textureLoader.load('Texturas/crack4.png'),
  textureLoader.load('Texturas/crack5.png'),
];
function initCrackOverlayInstance(crackTextures) {
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshBasicMaterial({
    map: crackTextures[0],
    transparent: true,
    depthTest: true,
    depthWrite: false,
    alphaTest: 0.1,
  });

  crackOverlayInstanceMesh = new THREE.Mesh(geometry, material);
  crackOverlayInstanceMesh.renderOrder = 999;
  crackOverlayInstanceMesh.visible = false;
  scene.add(crackOverlayInstanceMesh);
}
initCrackOverlayInstance(texturesCrack);

const crackOverlayMaterial = new THREE.MeshBasicMaterial({
  map: texturesCrack[0],
  transparent: true,
  depthTest: true,
  depthWrite: false,
});
const crackOverlayMesh = new THREE.Mesh(
  new THREE.BoxGeometry(1.01, 1.01, 1.01), // levemente más grande
  crackOverlayMaterial
);
crackOverlayMesh.renderOrder = 999;
crackOverlayMesh.visible = false;
scene.add(crackOverlayMesh);

const panel = document.getElementById("start-panel");
const button = document.getElementById("play-button");

async function goFullscreenLandscape() {
  try {
    // Fullscreen
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    
    // Orientación horizontal
    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientación:", e);
  }
  async function goFullscreenLandscape() {
  try {
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();

    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");

    resizeCanvas(); // Asegura que se actualice al instante
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientación:", e);
  }

  panel.style.display = "none";
}

  // Ocultar panel
  panel.style.display = "none";
}

// Mostrar el panel si se salió de fullscreen u orientación
function checkState() {
  const isFull = !!document.fullscreenElement;
  const isLandscape = screen.orientation?.type?.includes("landscape");
  
  if (!isFull || !isLandscape) {
    panel.style.display = "flex";
  }
}

button.addEventListener("click", goFullscreenLandscape);
document.addEventListener("fullscreenchange", checkState);
screen.orientation?.addEventListener("change", checkState);

// También se comprueba al rotar el dispositivo
window.addEventListener("resize", checkState);
const jumpButton = document.getElementById("jump-button");
function createBlockGeometryFromAtlas(faceIndices) {
  const tileCount = 3; // 3x3 bloques
  const tileSize = 1 / tileCount;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const uvs = geometry.attributes.uv;

  for (let i = 0; i < 6; i++) {
    const index = faceIndices[i];
    const tx = index % tileCount;
    const ty = Math.floor(index / tileCount);
    const uMin = tx * tileSize;
    const vMin = 1 - (ty + 1) * tileSize;
    const uMax = uMin + tileSize;
    const vMax = vMin + tileSize;

    const uvIndex = i * 8;

    // Cada cara tiene 4 vértices (2 triángulos)
    uvs.array[uvIndex + 0] = uMin; uvs.array[uvIndex + 1] = vMax;
    uvs.array[uvIndex + 2] = uMax; uvs.array[uvIndex + 3] = vMax;
    uvs.array[uvIndex + 4] = uMin; uvs.array[uvIndex + 5] = vMin;
    uvs.array[uvIndex + 6] = uMax; uvs.array[uvIndex + 7] = vMin;
  }

  uvs.needsUpdate = true;
  return geometry;
}

function createBlock(x, y, z, type) {
  let faceIndices;

  // Asignar índice del atlas a cada cara
  if (type === "grass") {
    faceIndices = [2, 2, 0, 3, 2, 2]; // lados, arriba, abajo, frente, atrás
  } else if (type === "dirt") {
    faceIndices = new Array(6).fill(3); // todas iguales
  } else if (type === "stone") {
    faceIndices = new Array(6).fill(1);
  } else {
    faceIndices = new Array(6).fill(4); // fallback
  }

  const geometry = createBlockGeometryFromAtlas(faceIndices);
  const block = new THREE.Mesh(geometry, atlasMaterial);

  block.position.set(x, y, z);
  block.castShadow = true;
  block.receiveShadow = true;
block.userData.resistance = resistencia; // por ejemplo: Math.random() * 1.5 + 0.5;
block.userData.currentBreak = 0;

  block.userData = {
    type: type,
    resistance: type === "stone" ? 3 : type === "dirt" ? 1.5 : 1,
    currentBreak: 0,
    crackMaterial: null
  };

  return block;
}

function generarOrdenEspiral(radio) {
  const orden = [];
  let x = 0, z = 0, dx = 0, dz = -1;
  for (let i = 0; i < Math.pow((radio * 2 + 1), 2); i++) {
    if (Math.abs(x) <= radio && Math.abs(z) <= radio) {
      orden.push([x, z]);
    }
    if (x === z || (x < 0 && x === -z) || (x > 0 && x === 1 - z)) {
      [dx, dz] = [-dz, dx]; // rotar
    }
    x += dx;
    z += dz;
  }
  return orden;
}
function mostrarVecinosSiAhoraEstanExpuestos(cx, cz, lx, ly, lz) {
  const dirs = [
    [1, 0, 0], [-1, 0, 0],
    [0, 1, 0], [0, -1, 0],
    [0, 0, 1], [0, 0, -1],
  ];

  for (const [dx, dy, dz] of dirs) {
    const nx = lx + dx;
    const ny = ly + dy;
    const nz = lz + dz;

    const key = `${cx},${cz}`;
    const chunk = loadedChunks.get(key);
    if (!chunk?.blocks?.[nx]?.[ny]?.[nz]) continue;

    const blockData = chunk.blocks[nx][ny][nz];
    if (!blockData.exists) continue;

    // Verificar si sigue oculto por vecinos
    let oculto = true;

    for (const [ddx, ddy, ddz] of dirs) {
      const xx = nx + ddx;
      const yy = ny + ddy;
      const zz = nz + ddz;
      const vecino = chunk.blocks?.[xx]?.[yy]?.[zz];
      if (!vecino || !vecino.exists) {
        oculto = false;
        break;
      }
    }

    if (!oculto) {
      // Reposicionar el bloque (ya tenía una instancia en 9999)
      const mesh = chunk.mesh.children.find(m => m instanceof THREE.InstancedMesh && m.geometry === geometries[blockData.type]);
      if (mesh && blockData.instanceIndex !== undefined) {
        const dummy = new THREE.Object3D();
        dummy.position.set((cx * CHUNK_SIZE + nx), ny, (cz * CHUNK_SIZE + nz));
        dummy.updateMatrix();
        mesh.setMatrixAt(blockData.instanceIndex, dummy.matrix);
        mesh.instanceMatrix.needsUpdate = true;
      }
    }
  }
}


const deletedBlocks = new Map(); // clave: \"chunkKey|x,y,z\" → true
const tips = [
  "el lag es parte del juego",
  "ten paciencia ",
  "usa [pri] para romper o golpear",
  "con [sec] puedes poner bloques o usar algo",
  "Cambia la distancia de renderizado en ajustes.",
  "Explora, construye y destruye como quieras.",
  "Puedes activar o desactivar sombras.",
  "Toca dos veces salto para bajar en espectador.",
  "Explora, construye y destruye como quieras.",
  "Usa el joystick para moverte en cualquier dirección.",
  "Presiona el botón para saltar obstáculos.",
  "Mantén presionado para romper bloques.",
  "Cambia entre 1ra, 2da y 3ra persona tocando el botón de cámara.",
  "Activa el modo espectador para volar por el mundo.",
  "Puedes atravesar paredes en modo espectador.",
  "Toca dos veces salto para bajar mientras vuelas.",
  "Modifica la distancia de renderizado desde el menú de pausa.",
  "Activa o desactiva sombras para mejorar el rendimiento.",
  "Los bloques de piedra son más resistentes.",
  "Solo puedes romper bloques si estás cerca.",
  "No todos los bloques necesitan romperse para explorar.",
  "Aléjate para que los chunks lejanos se descarguen.",
  "Cuidado: los bloques no flotan solos por mucho tiempo.",
  "Personaliza los controles desde el panel de ajustes.",
  "Descubre cuevas ocultas bajo tierra.",
  "Construye escaleras o torres con bloques que tú pongas.",
  "Experimenta con distintas vistas para explorar mejor.",
  "Tienes el control total del mundo: ¡sé creativo!"

];

const tipDiv = document.getElementById("tip-carga");
let tipsMostrados = [];
let tipIndex = 0;
let tipTimer = null;

function mostrarSiguienteTip() {
  if (tipsMostrados.length === tips.length) {
    tipsMostrados = []; // reset si ya se mostraron todos
  }

  let nuevoTip;
  do {
    tipIndex = Math.floor(Math.random() * tips.length);
    nuevoTip = tips[tipIndex];
  } while (tipsMostrados.includes(nuevoTip));

  tipsMostrados.push(nuevoTip);
  tipDiv.textContent = " " + nuevoTip;

  reiniciarTemporizador();
}

function reiniciarTemporizador() {
  clearTimeout(tipTimer);
  tipTimer = setTimeout(mostrarSiguienteTip, 5000);
}

// Cambiar tip si se hace clic
tipDiv.addEventListener("click", mostrarSiguienteTip);

// Iniciar el primer tip
mostrarSiguienteTip();


const CHUNK_SIZE = 5;
let RENDER_HACIA_ABAJO = 5;

let RENDER_DISTANCE = 1; // ✅ para poder modificarla con el slider


let chunksCargados = 0;
let totalChunksIniciales = 0;
let pantallaYaOcultada = false;
const renderDownSlider = document.getElementById("render-down-slider");
const renderDownValue = document.getElementById("render-down-value");

renderDownSlider.addEventListener("input", () => {
  RENDER_HACIA_ABAJO = parseInt(renderDownSlider.value);
  renderDownValue.textContent = RENDER_HACIA_ABAJO;
  updateChunksAroundPlayer(); // fuerza regeneración
});

const loadedChunks = new Map();
function createBlockGeometryFromAtlas(faceIndices) {
  const tileCount = 3; // 3x3 en el atlas
  const tileSize = 1 / tileCount;
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const uvs = geometry.attributes.uv;

  for (let i = 0; i < 6; i++) {
    const index = faceIndices[i];
    const tx = index % tileCount;
    const ty = Math.floor(index / tileCount);
    const uMin = tx * tileSize;
    const vMin = 1 - (ty + 1) * tileSize;
    const uMax = uMin + tileSize;
    const vMax = vMin + tileSize;

    const uvIndex = i * 8;

    uvs.array[uvIndex + 0] = uMin; uvs.array[uvIndex + 1] = vMax;
    uvs.array[uvIndex + 2] = uMax; uvs.array[uvIndex + 3] = vMax;
    uvs.array[uvIndex + 4] = uMin; uvs.array[uvIndex + 5] = vMin;
    uvs.array[uvIndex + 6] = uMax; uvs.array[uvIndex + 7] = vMin;
  }

  uvs.needsUpdate = true;
  return geometry;
}
function posicionarJugadorInicial(intentos = 0) {
  const px = 0;
  const pz = 0;
  const cx = Math.floor(px / CHUNK_SIZE);
  const cz = Math.floor(pz / CHUNK_SIZE);
  const key = `${cx},${cz}`;

  const chunk = loadedChunks.get(key);

  if (!chunk) {
    if (intentos < 50) {
      setTimeout(() => posicionarJugadorInicial(intentos + 1), 100);
    } else {
      console.warn("❌ No se pudo encontrar chunk para posicionar al jugador.");
    }
    return;
  }

  let altura = -1;
  const bx = px % CHUNK_SIZE;
  const bz = pz % CHUNK_SIZE;

  for (let y = 20; y >= 0; y--) {
    if (chunk.blocks?.[bx]?.[y]?.[bz]?.exists) {
      altura = y;
      break;
    }
  }

  if (altura === -1) {
    if (intentos < 50) {
      setTimeout(() => posicionarJugadorInicial(intentos + 1), 100);
    } else {
      console.warn("❌ No se encontró altura válida para colocar al jugador.");
    }
    return;
  }

  // ✅ Posicionar al jugador justo encima
  player.position.set(px + 0.5, altura + 1.5, pz + 0.5);
  velocityY = 0;
}

function generateChunk(cx, cz) {
  const key = `${cx},${cz}`;
  if (loadedChunks.has(key)) return;

  const group = new THREE.Group();
  group.name = `chunk_${cx}_${cz}`;

  const blocks = {};
  const meshMap = {};
  const counters = {};
  const MAX = 4096;

  const types = ["grass", "dirt", "stone", "bedrock"];
  for (const type of types) {
    const mesh = new THREE.InstancedMesh(geometries[type], atlasMaterial, MAX);
    mesh.frustumCulled = false;
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    group.add(mesh);
    meshMap[type] = mesh;
    counters[type] = 0;
  }

  const dummy = new THREE.Object3D();
  const yMin = -64;

  for (let x = 0; x < CHUNK_SIZE; x++) {
    for (let z = 0; z < CHUNK_SIZE; z++) {
      const worldX = cx * CHUNK_SIZE + x;
      const worldZ = cz * CHUNK_SIZE + z;

      const noise = simplex.noise2D(worldX / 20, worldZ / 20);
      const surfaceY = Math.max(64, Math.floor(64 + noise * 2));

      for (let y = yMin; y <= surfaceY; y++) {
        // 🔽 Limitar renderizado hacia abajo
        const alturaJugador = Math.floor(player.position.y);
        if (y < alturaJugador - RENDER_HACIA_ABAJO) continue;

        let type = "stone";
        if (y === yMin) type = "bedrock";
        else if (y >= surfaceY - 3 && y < surfaceY) type = "dirt";
        else if (y === surfaceY) type = "grass";

        const delKey = `${cx},${cz}|${x},${y},${z}`;
        if (deletedBlocks.has(delKey)) continue;

        const i = counters[type]++;
        if (i >= MAX) continue;

        dummy.position.set(worldX, y, worldZ);
        dummy.updateMatrix();
        meshMap[type].setMatrixAt(i, dummy.matrix);

        if (!blocks[x]) blocks[x] = {};
        if (!blocks[x][y]) blocks[x][y] = {};
        blocks[x][y][z] = { instanceIndex: i, type, exists: true };
      }
    }
  }

  scene.add(group);
  loadedChunks.set(key, {
  mesh: group,
  blocks: blocks,
  alturaGenerada: Math.floor(player.position.y)  // << 🔍 nueva propiedad
});

}
function actualizarVisibilidadBloques(cx, cz) {
  const key = `${cx},${cz}`;
  const chunk = loadedChunks.get(key);
  if (!chunk) return;

  const bloques = chunk.blocks;
  const grupo = chunk.mesh;

  const dummy = new THREE.Object3D();

  const dirs = [
    [1, 0, 0], [-1, 0, 0],
    [0, 1, 0], [0, -1, 0],
    [0, 0, 1], [0, 0, -1],
  ];

  for (let x in bloques) {
    for (let y in bloques[x]) {
      for (let z in bloques[x][y]) {
        const data = bloques[x][y][z];
        if (!data.exists) continue;

        let rodeado = true;

        for (let [dx, dy, dz] of dirs) {
          const nx = parseInt(x) + dx;
          const ny = parseInt(y) + dy;
          const nz = parseInt(z) + dz;

          if (!bloques[nx]?.[ny]?.[nz]?.exists) {
            rodeado = false;
            break;
          }
        }

        const mesh = grupo.children.find(m => m instanceof THREE.InstancedMesh && m.geometry === geometries[data.type]);
        if (!mesh || data.instanceIndex === undefined) continue;

        if (rodeado) {
          dummy.position.set(9999, 9999, 9999); // ocultar
        } else {
          const worldX = cx * CHUNK_SIZE + parseInt(x);
          const worldY = parseInt(y);
          const worldZ = cz * CHUNK_SIZE + parseInt(z);
          dummy.position.set(worldX, worldY, worldZ);
        }

        dummy.updateMatrix();
        mesh.setMatrixAt(data.instanceIndex, dummy.matrix);
      }
    }
  }

  for (const mesh of grupo.children) {
    if (mesh instanceof THREE.InstancedMesh) {
      mesh.instanceMatrix.needsUpdate = true;
    }
  }
}
setInterval(() => {
  for (const key of loadedChunks.keys()) {
    const [cx, cz] = key.split(',').map(Number);
    actualizarVisibilidadBloques(cx, cz);
  }
}, 100); // cada 1 segundo

setTimeout(() => {
  const pantalla = document.getElementById("pantalla-carga");
  if (pantalla) pantalla.style.display = "none";
  console.log("⏳ Pantalla de carga oculta tras 30 segundos.");
}, 5000); // ← Cambia este valor si quieres otro tiempo


function updateChunksAroundPlayer() {
  const px = Math.floor(player.position.x / CHUNK_SIZE);
  const pz = Math.floor(player.position.z / CHUNK_SIZE);

  const seen = new Set();
  const chunksToGenerate = [];

  for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
    for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
      const cx = px + dx;
      const cz = pz + dz;
      const key = `${cx},${cz}`;
      seen.add(key);
      const chunk = loadedChunks.get(key);
const alturaJugador = Math.floor(player.position.y);

if (!chunk) {
  chunksToGenerate.push([cx, cz]);
} else {
  const diferenciaAltura = Math.abs(chunk.alturaGenerada - alturaJugador);
  if (diferenciaAltura > RENDER_HACIA_ABAJO) {
    // Eliminar chunk para regenerarlo con nueva altura visible
    scene.remove(chunk.mesh);
    loadedChunks.delete(key);
    chunksToGenerate.push([cx, cz]);
  }
}

    }
  }
  
  function posicionarJugadorInicial(intentos = 0) {
  const px = 0;
  const pz = 0;
  const cx = Math.floor(px / CHUNK_SIZE);
  const cz = Math.floor(pz / CHUNK_SIZE);
  const key = `${cx},${cz}`;

  const chunk = loadedChunks.get(key);

  if (!chunk) {
    if (intentos < 50) {
      setTimeout(() => posicionarJugadorInicial(intentos + 1), 100);
    } else {
      console.warn("❌ No se pudo encontrar chunk para posicionar al jugador.");
    }
    return;
  }

  let altura = -1;
  const bx = px % CHUNK_SIZE;
  const bz = pz % CHUNK_SIZE;

  for (let y = 20; y >= 0; y--) {
    if (chunk.blocks?.[bx]?.[y]?.[bz]?.exists) {
      altura = y;
      break;
    }
  }

  if (altura === -1) {
    if (intentos < 50) {
      setTimeout(() => posicionarJugadorInicial(intentos + 1), 100);
    } else {
      console.warn("❌ No se encontró altura válida para colocar al jugador.");
    }
    return;
  }

  // ✅ Posicionar al jugador justo encima
  player.position.set(px + 0.5, altura + 1.5, pz + 0.5);
  velocityY = 0;
}

const textoCarga = document.getElementById("texto-carga");
let puntos = 0;
setInterval(() => {
  puntos = (puntos + 1) % 4;
  textoCarga.textContent = "cargando" + ".".repeat(puntos);
}, 1000);

  // Cargar lentamente, uno cada 50ms
  const orden = generarOrdenEspiral(RENDER_DISTANCE);
orden.forEach(([dx, dz], index) => {
  const cx = px + dx;
  const cz = pz + dz;
  const key = `${cx},${cz}`;
  if (!loadedChunks.has(key)) {
    setTimeout(() => generateChunk(cx, cz), index * 200); // carga suave
  }
});


  // Eliminar chunks fuera del rango
  for (let key of loadedChunks.keys()) {
    if (!seen.has(key)) {
      const chunk = loadedChunks.get(key);
      scene.remove(chunk.mesh);
      loadedChunks.delete(key);
    }
  }
}




const faceTexture = loader.load('Texturas/cub.png');

const materials = [
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara derecha
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara izquierda
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara arriba
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara abajo
  new THREE.MeshStandardMaterial({ map: faceTexture }), // cara frontal (z positiva)
  new THREE.MeshStandardMaterial({ color: 0x0000ff })  // cara trasera
];

const playerGeometry = new THREE.BoxGeometry(0.8, 0.9, 0.8);
const player = new THREE.Mesh(playerGeometry, materials);
player.castShadow = true;
player.receiveShadow = true;
scene.add(player);



const raycaster = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);
function hayEspacioParaSaltar() {
  const start = player.position.clone().add(new THREE.Vector3(0, 0.5, 0));
  const dir = new THREE.Vector3(0, 1, 0);
  raycaster.ray.origin.copy(start);
  raycaster.ray.direction.copy(dir);

  const intersects = raycaster.intersectObjects(terrain, false);
  for (const hit of intersects) {
    if (hit.distance <= 0.9) return false; // solo bloquea si el obstáculo está a 1.1 o menos
  }

  return true;
}
// Líneas de colisión y raycaster
const debugLines = [];
function dibujarDebugColisiones() {
  debugLines.forEach(line => scene.remove(line));
  debugLines.length = 0;

  if (!mostrarColisiones) return;

  const offsets = [
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0.3, 0, 0),
    new THREE.Vector3(-0.3, 0, 0),
    new THREE.Vector3(0, 0, 0.3),
    new THREE.Vector3(0, 0, -0.3)
  ];

  for (let offset of offsets) {
    const start = player.position.clone().add(offset).setY(player.position.y);
    const end = start.clone();
    end.y -= 3;

    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    debugLines.push(line);
  }

  const rayStart = new THREE.Vector3(player.position.x, 50, player.position.z);
  const rayEnd = rayStart.clone().add(down.clone().multiplyScalar(50));
  const rayGeom = new THREE.BufferGeometry().setFromPoints([rayStart, rayEnd]);
  const rayLine = new THREE.Line(rayGeom, new THREE.LineBasicMaterial({ color: 0xffff00 }));
  scene.add(rayLine);
  debugLines.push(rayLine);
}
function obtenerBloquesCercanos(x, z, rango = 1) {
  const bloques = [];

  const cx = Math.floor(x / CHUNK_SIZE);
  const cz = Math.floor(z / CHUNK_SIZE);

  for (let dx = -rango; dx <= rango; dx++) {
    for (let dz = -rango; dz <= rango; dz++) {
      const key = `${cx + dx},${cz + dz}`;
      const chunk = loadedChunks.get(key);
      if (!chunk) continue;

      for (let lx in chunk.blocks) {
        for (let y in chunk.blocks[lx]) {
          for (let lz in chunk.blocks[lx][y]) {
            const data = chunk.blocks[lx][y][lz];
            if (data.exists && data.mesh) {
              bloques.push(data.mesh);
            }
          }
        }
      }
    }
  }

  return bloques;
}

function getGroundHeight(x, z) {
  raycaster.ray.origin.set(x, player.position.y + 1, z);
  raycaster.ray.direction.set(0, -1, 0);

  const hits = raycaster.intersectObjects(bloquesFisicos, false);

  if (hits.length > 0) {
    // Devuelve la parte superior del bloque (y del centro + 0.5)
    return hits[0].object.position.y + 0.5;
  }

  return -Infinity;
}

function getNearbyBlockBoxes(x, y, z) {
  const cx = Math.floor(x / CHUNK_SIZE);
  const cz = Math.floor(z / CHUNK_SIZE);
  const bloques = [];

  for (let dx = -1; dx <= 1; dx++) {
    for (let dz = -1; dz <= 1; dz++) {
      const key = `${cx + dx},${cz + dz}`;
      const chunk = loadedChunks.get(key);
      if (!chunk) continue;

      const blocks = chunk.blocks;
      for (const lx in blocks) {
        for (const ly in blocks[lx]) {
          for (const lz in blocks[lx][ly]) {
            const b = blocks[lx][ly][lz];
            if (!b.exists) continue;

            const wx = (cx + dx) * CHUNK_SIZE + parseInt(lx);
            const wy = parseInt(ly);
            const wz = (cz + dz) * CHUNK_SIZE + parseInt(lz);

            bloques.push({ x: wx, y: wy, z: wz });
          }
        }
      }
    }
  }

  return bloques;
}
function colisionaAABB(x, y, z, ancho = 0.6, alto = 0.9) {
  const min = { x: x - ancho / 2, y: y, z: z - ancho / 2 };
  const max = { x: x + ancho / 2, y: y + alto, z: z + ancho / 2 };

  const bloques = getNearbyBlockBoxes(x, y, z);

  for (const b of bloques) {
    const bloqueMin = { x: b.x, y: b.y, z: b.z };
    const bloqueMax = { x: b.x + 1, y: b.y + 1, z: b.z + 1 };

    const colisiona =
      min.x < bloqueMax.x && max.x > bloqueMin.x &&
      min.y < bloqueMax.y && max.y > bloqueMin.y &&
      min.z < bloqueMax.z && max.z > bloqueMin.z;

    if (colisiona) return true;
  }

  return false;
}

const pauseBtn = document.getElementById("pause-button");
const pauseMenu = document.getElementById("pause-menu");
const resumeBtn = document.getElementById("resume-btn");

let sombrasActivas = false; // Estado inicial: desactivadas
const spectatorToggle = document.getElementById("spectator-toggle");

spectatorToggle.addEventListener("click", () => {
  modoEspectador = !modoEspectador;
  spectatorToggle.textContent = "Espectador: " + (modoEspectador ? "ON" : "OFF");
  spectatorToggle.classList.toggle("on", modoEspectador);
});

const shadowToggle = document.getElementById("shadow-toggle");
const updateSombras = () => {
  dirLight.castShadow = sombrasActivas;

  scene.traverse(obj => {
    if (obj.isMesh) {
      obj.castShadow = sombrasActivas;
      obj.receiveShadow = sombrasActivas;
    }
  });

  shadowToggle.textContent = sombrasActivas ? "Sombras: ON" : "Sombras: OFF";
  shadowToggle.classList.toggle("on", sombrasActivas);
};
const openBtn = document.getElementById('open-panel-btn');
const slidePanel = document.getElementById('slide-panel');
const closeBtn = document.getElementById('close-panel-btn');

openBtn.addEventListener('click', () => {
  slidePanel.classList.add('open');
});

closeBtn.addEventListener('click', () => {
  slidePanel.classList.remove('open');
});

let bloquesFisicos = [];

function actualizarBloquesFisicos() {
  // Eliminar los antiguos
  for (const m of bloquesFisicos) {
    scene.remove(m);
  }
  bloquesFisicos = [];

  const cx = Math.floor(player.position.x / CHUNK_SIZE);
  const cz = Math.floor(player.position.z / CHUNK_SIZE);

  const r = 1; // rango de chunks alrededor

  for (let dx = -r; dx <= r; dx++) {
    for (let dz = -r; dz <= r; dz++) {
      const key = `${cx + dx},${cz + dz}`;
      const chunk = loadedChunks.get(key);
      if (!chunk) continue;

      for (const lx in chunk.blocks) {
        for (const ly in chunk.blocks[lx]) {
          for (const lz in chunk.blocks[lx][ly]) {
            const block = chunk.blocks[lx][ly][lz];
            if (!block.exists) continue;

            const worldX = (cx + dx) * CHUNK_SIZE + parseInt(lx);
            const worldY = parseInt(ly);
            const worldZ = (cz + dz) * CHUNK_SIZE + parseInt(lz);

            // Solo los que están cerca del jugador (radio de 3 bloques)
            const dist = player.position.distanceTo(new THREE.Vector3(worldX, worldY, worldZ));
            if (dist > 3.5) continue;

            // Crear Mesh individual invisible (solo para colisión)
            const m = new THREE.Mesh(
  new THREE.BoxGeometry(1, 1, 1),
  new THREE.MeshBasicMaterial({ color: 0xff0000, visible: false }) // invisible
);
m.position.set(worldX + 0.5, worldY + 0.5, worldZ + 0.5); // CENTRO del bloque
m.updateMatrixWorld();

            m.position.set(worldX, worldY, worldZ);
            scene.add(m);
            bloquesFisicos.push(m);
          }
        }
      }
    }
  }
}
function colisionaConBloquesFisicos(x, y, z) {
  const ancho = 0.6;
  const alto = 0.9;

  const jugadorMin = new THREE.Vector3(x - ancho / 2, y, z - ancho / 2);
  const jugadorMax = new THREE.Vector3(x + ancho / 2, y + alto, z + ancho / 2);

  for (const bloque of bloquesFisicos) {
    bloque.geometry.computeBoundingBox();
    const box = bloque.geometry.boundingBox.clone();
    box.applyMatrix4(bloque.matrixWorld);

    const intersecta =
      jugadorMin.x < box.max.x && jugadorMax.x > box.min.x &&
      jugadorMin.y < box.max.y && jugadorMax.y > box.min.y &&
      jugadorMin.z < box.max.z && jugadorMax.z > box.min.z;

    if (intersecta) return true;
  }

  return false;
}

const showDebugBtn = document.createElement('div');
showDebugBtn.id = 'collision-toggle';
showDebugBtn.textContent = 'Colisiones: OFF';
showDebugBtn.style.position = 'absolute';
showDebugBtn.style.top = '140px';
showDebugBtn.style.left = '50%';
showDebugBtn.style.transform = 'translateX(-50%)';
showDebugBtn.style.width = '180px';
showDebugBtn.style.height = '40px';
showDebugBtn.style.backgroundColor = '#444'; // Se sobreescribe por .on
showDebugBtn.style.color = 'white';
showDebugBtn.style.fontSize = '14px';
showDebugBtn.style.textAlign = 'center';
showDebugBtn.style.lineHeight = '40px';
showDebugBtn.style.zIndex = '20';
showDebugBtn.style.cursor = 'pointer';

let colisionesActivas = false;

showDebugBtn.onclick = () => {
  colisionesActivas = !colisionesActivas;
  showDebugBtn.textContent = colisionesActivas ? "Colisiones: ON" : "Colisiones: OFF";
  showDebugBtn.classList.toggle("on", colisionesActivas);
};

slidePanel.appendChild(showDebugBtn);

setInterval(() => {
  if (!modoEspectador) actualizarBloquesFisicos();
}, 300);

let mostrarColisiones = false;
showDebugBtn.addEventListener('click', () => {
  mostrarColisiones = !mostrarColisiones;
  showDebugBtn.textContent = mostrarColisiones ? 'Colisiones: ON' : 'Colisiones: OFF';
  // aquí llamarías a la función que muestra/oculta las colisiones
});

// Palanca
shadowToggle.addEventListener("click", () => {
  sombrasActivas = !sombrasActivas;
  updateSombras();
});

// Aplicar sombras al iniciar (están apagadas)
updateSombras();

let paused = false;

pauseBtn.addEventListener("click", () => {
  paused = true;
  pauseMenu.style.display = "flex";
});

resumeBtn.addEventListener("click", () => {
  paused = false;
  pauseMenu.style.display = "none";
});




// Variables para joystick
const joystick = document.getElementById("joystick");
const thumb = joystick.children[0];
let joystickActive = false;
let joystickStart = {x:0,y:0};
let moveVector = new THREE.Vector2(0,0);

joystick.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (joystickTouchId === null) {
      joystickTouchId = touch.identifier;
      joystickActive = true;
      joystickStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId && joystickActive) {
      const deltaX = (touch.clientX - joystickStart.x) / 50;
      const deltaY = (touch.clientY - joystickStart.y) / 50;
      moveVector.set(
        Math.max(-1, Math.min(1, deltaX)),
        Math.max(-1, Math.min(1, deltaY))
      );
      thumb.style.left = 35 + moveVector.x * 30 + "px";
      thumb.style.top  = 35 + moveVector.y * 30 + "px";
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      joystickTouchId = null;
      joystickActive = false;
      moveVector.set(0, 0);
      thumb.style.left = "35px";
      thumb.style.top  = "35px";
      e.preventDefault();
      break;
    }
  }
});

// Variables para control de cámara con swipe
let camYaw = 0;
let camPitch = 0;
const camDistance = 5;
let looking = false;
let lookStart = {x:0,y:0};

function isTouchOnJoystick(touch){
  const r = joystick.getBoundingClientRect();
  return (touch.clientX>=r.left && touch.clientX<=r.right && touch.clientY>=r.top && touch.clientY<=r.bottom);
}

renderer.domElement.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (!isTouchOnJoystick(touch) && cameraTouchId === null) {

      cameraTouchId = touch.identifier;
      looking = true;
      lookStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId && looking) {
      if (isTouchOnJoystick(touch)) return;
      const dx = touch.clientX - lookStart.x;
      const dy = touch.clientY - lookStart.y;
      lookStart.x = touch.clientX;
      lookStart.y = touch.clientY;
      camYaw   -= dx * 0.005;
      camPitch -= dy * 0.005;
      const maxP = Math.PI / 2 - 0.1;
      const minP = -maxP;
      camPitch = Math.max(minP, Math.min(maxP, camPitch));
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId) {
      cameraTouchId = null;
      looking = false;
      e.preventDefault();
      break;
    }
  }
});

const jumpSpeed = 0.23;
let velocityY = 0;
let onGround = false;
let jumpPressed = false;


function jump(){
  if (onGround && hayEspacioParaSaltar()) {
    velocityY = jumpSpeed;
    onGround = false;
  }
}

jumpButton.addEventListener("touchstart", e => {
  e.preventDefault();

  const now = performance.now();
  if (modoEspectador && now - dobleToqueTiempo < 400) {
    bajando = true;
  } else {
    dobleToqueTiempo = now;
    jumpPressed = true;
    if (!modoEspectador) jump();
  }
});

jumpButton.addEventListener("touchend", e => {
  e.preventDefault();
  jumpPressed = false;
  bajando = false;
});


let camMode = 0; // 0 = 1ra, 1 = 3ra, 2 = 2da

const camToggleBtn = document.getElementById("camera-toggle");
camToggleBtn.addEventListener("click", () => {
  camMode = (camMode + 1) % 3;
  const labels = ["1ra", "2da", "3ra"];
  camToggleBtn.textContent = ` ${labels[camMode]}`;
  player.visible = camMode !== 0;
});

// Función animación y lógica
const moveSpeed = 0.3;
const priButton = document.getElementById("pri-button");

let breaking = false;
let currentTarget = null;
let breakStartTime = 0;

let currentInstance = null;
let currentMesh = null;

priButton.addEventListener("touchstart", () => {
  const raycaster = new THREE.Raycaster();
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  raycaster.set(camera.position, dir);

  for (const chunkEntry of loadedChunks.entries()) {
    const [chunkKey, chunkData] = chunkEntry;
    const [cx, cz] = chunkKey.split(",").map(Number);

    for (const mesh of chunkData.mesh.children) {
      if (!(mesh instanceof THREE.InstancedMesh)) continue;

      const hits = raycaster.intersectObject(mesh, true);
      if (hits.length > 0) {
        const { instanceId } = hits[0];
        crackInstanceId = instanceId;
        crackInstancedMesh = mesh;
        crackStartTime = performance.now();
        crackBreaking = true;
        return;
      }
    }
  }
});

priButton.addEventListener("touchend", () => {
  crackBreaking = false;
  hideCrackOverlay();
});

function showCrackOverlay(pos, progress, textures) {
  const idx = Math.min(Math.floor(progress * textures.length), textures.length - 1);
  crackOverlayObj.position.copy(pos);
  crackOverlayObj.material.map = textures[idx];
  crackOverlayObj.material.needsUpdate = true;
  crackOverlayObj.visible = true;
}

function hideCrackOverlay() {
  crackOverlayObj.visible = false;
}

function setBlockResistanceAt(cx, cz, lx, ly, lz, value) {
  const key = `${cx},${cz}|${lx},${ly},${lz}`;
  crackResistances.set(key, value);
}

function getBlockResistanceAt(cx, cz, lx, ly, lz) {
  const key = `${cx},${cz}|${lx},${ly},${lz}`;
  return crackResistances.get(key) ?? 1;
}

function addCrackLayer(instanceMatrix, index) {
  crackOverlayMesh.material.map = texturesCrack[index];
  crackOverlayMesh.material.needsUpdate = true;
  crackOverlayMesh.visible = true;

  const matrix = new THREE.Matrix4();
  matrix.fromArray(instanceMatrix);
  crackOverlayMesh.matrix.copy(matrix);
  crackOverlayMesh.matrix.decompose(
    crackOverlayMesh.position,
    crackOverlayMesh.quaternion,
    crackOverlayMesh.scale
  );
}
function updateCrackOverlayInstance(position, progress, crackTextures) {
  if (!crackOverlayInstanceMesh) return;

  const index = Math.min(Math.floor(progress * crackTextures.length), crackTextures.length - 1);
  crackOverlayInstanceMesh.material.map = crackTextures[index];
  crackOverlayInstanceMesh.material.needsUpdate = true;

  crackOverlayInstanceMesh.position.copy(position);
  crackOverlayInstanceMesh.visible = true;
}
function hideCrackOverlayInstance() {
  if (crackOverlayInstanceMesh) {
    crackOverlayInstanceMesh.visible = false;
  }
}

function updateCrackLayer(progress) {
  const index = Math.min(Math.floor(progress * texturesCrack.length), texturesCrack.length - 1);
  crackOverlayMesh.material.map = texturesCrack[index];
  crackOverlayMesh.material.needsUpdate = true;
}

function removeCrackOverlay() {
  crackOverlayMesh.visible = false;
}

const maxBreakDistance = 6;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const cercanos = obtenerBloquesCercanos(player.position.x, player.position.z);
const intersects = raycaster.intersectObjects(cercanos, false);

  if (intersects.length > 0) {
    const target = intersects[0].object;
    const distance = camera.position.distanceTo(target.position);
    if (distance <= maxBreakDistance) {
      currentTarget = target;
      breakStartTime = performance.now();
      breaking = true;
    }
  }
});

function animate() {
  requestAnimationFrame(animate);
  if (crackBreaking && crackInstanceId !== null && crackInstancedMesh) {
  const dummy = new THREE.Object3D();
  crackInstancedMesh.getMatrixAt(crackInstanceId, dummy.matrix);
  dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

  const dist = camera.position.distanceTo(dummy.position);
  if (dist > maxBreakDistance) {
    crackBreaking = false;
    hideCrackOverlay();
    return;
  }

  const chunkEntry = Array.from(loadedChunks.entries()).find(([, c]) =>
    c.mesh.children.includes(crackInstancedMesh)
  );

  if (!chunkEntry) return;
  const [chunkKey, chunkData] = chunkEntry;
  const [cx, cz] = chunkKey.split(",").map(Number);
  const lx = Math.floor(dummy.position.x) % CHUNK_SIZE;
  const ly = Math.floor(dummy.position.y);
  const lz = Math.floor(dummy.position.z) % CHUNK_SIZE;
  const idKey = `${chunkKey}|${lx},${ly},${lz}`;

  if (!crackBreakProgress[idKey]) crackBreakProgress[idKey] = 0;

  const delta = 0.016;
  crackBreakProgress[idKey] += delta;

  const resistencia = getBlockResistanceAt(cx, cz, lx, ly, lz);
  const progress = crackBreakProgress[idKey] / resistencia;

  showCrackOverlay(dummy.position, progress, texturesCrack);

  if (progress >= 1) {
    // Eliminar instancia
    const hidden = new THREE.Object3D();
    hidden.position.set(9999, 9999, 9999);
    hidden.updateMatrix();
    crackInstancedMesh.setMatrixAt(crackInstanceId, hidden.matrix);
    crackInstancedMesh.instanceMatrix.needsUpdate = true;

    deletedBlocks.set(idKey, true);
    if (chunkData.blocks?.[lx]?.[ly]?.[lz]) {
      chunkData.blocks[lx][ly][lz].exists = false;
    }
mostrarVecinosSiAhoraEstanExpuestos(cx, cz, lx, ly, lz);

    delete crackBreakProgress[idKey];
    hideCrackOverlay();

    crackInstanceId = null;
    crackInstancedMesh = null;
    crackBreaking = false;
  }
}

  const enableStepUp = false;
const breakBarContainer = document.getElementById('break-bar-container');
const breakBar = document.getElementById('break-bar');

function updateBreakBar(progress) {
  if (progress > 0 && progress < 1) {
    breakBarContainer.style.display = 'block';
    breakBar.style.width = (progress * 100) + '%';
  } else {
    breakBarContainer.style.display = 'none';
    breakBar.style.width = '0%';
  }
}

  // Movimiento relativo a la cámara
  if (moveVector.lengthSq() > 0.01) {
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();

    const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

    const moveDir = new THREE.Vector3();
    moveDir.addScaledVector(camDir, -moveVector.y);
    moveDir.addScaledVector(camRight, moveVector.x);
    moveDir.normalize();

    const moveStep = moveDir.clone().multiplyScalar(moveSpeed);

    const playerRadius = 0.3;
const playerHeight = 0.9;

    const stepHeight = 0.1;

    // 👇 NUEVO: deslizamiento por separado en X y Z
    const moveX = new THREE.Vector3(moveStep.x, 0, 0);
    const moveZ = new THREE.Vector3(0, 0, moveStep.z);

    const yOffsets = [0, 0.4, 0.8];


    let canMoveX = true;
    let canMoveZ = true;

    // Comprobar colisión en X
    for (let yOffset of yOffsets) {
      const pos = player.position.clone().add(moveX);
      pos.y += yOffset;

      const offsets = [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ];

      let collision = false;
      for (let offset of offsets) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.45) {
          collision = true;
        }
      }
      if (collision) canMoveX = false;
    }

    // Comprobar colisión en Z
    for (let yOffset of yOffsets) {
      const pos = player.position.clone().add(moveZ);
      pos.y += yOffset;

      const offsets = [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ];

      let collision = false;
      for (let offset of offsets) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.45) {
          collision = true;
        }
      }
      if (collision) canMoveZ = false;
    }

    // Aplicar movimiento permitido para lograr deslizamiento
    if (modoEspectador) {
  player.position.add(moveStep); // 👻 atraviesa todo
} else {
  const newPos = player.position.clone().add(moveStep);

  // Primero: intenta moverse normalmente
  if (!colisionaConBloquesFisicos(newPos.x, newPos.y, newPos.z)) {
    player.position.copy(newPos);
  } else {
    // Segundo intento: mover con paso vertical pequeño (escalón)
    const escalonPos = newPos.clone();
    escalonPos.y += 0.5; // intenta subir medio bloque

    if (!colisionaConBloquesFisicos(escalonPos.x, escalonPos.y, escalonPos.z)) {
      player.position.copy(escalonPos);
    }
    // Si choca incluso con el paso, no se mueve
  }
}
}

  if (breaking) {
  // 🔷 BLOQUES NORMALES (con Mesh individuales)
  if (currentTarget && terrain.includes(currentTarget)) {
    const distance = camera.position.distanceTo(currentTarget.position);
    if (distance > maxBreakDistance) {
      breaking = false;
      removeCrackOverlay(currentTarget);
      currentTarget.userData.currentBreak = 0;
      currentTarget = null;
      updateBreakBar(0);
    } else {
      const delta = 0.016;
      const data = currentTarget.userData;
      data.currentBreak += delta;
      const progress = data.currentBreak / data.resistance;

      updateBreakBar(progress);
      updateCrackLayer(currentTarget, progress);

      if (progress >= 1) {
        // Eliminar visualmente
        if (currentTarget.parent) currentTarget.parent.remove(currentTarget);

        // Obtener coordenadas del bloque
        const worldPos = currentTarget.position;
        const cx = Math.floor(worldPos.x / CHUNK_SIZE);
        const cz = Math.floor(worldPos.z / CHUNK_SIZE);
        const lx = Math.floor(worldPos.x) % CHUNK_SIZE;
        const lz = Math.floor(worldPos.z) % CHUNK_SIZE;
        const ly = Math.floor(worldPos.y);
        const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
        deletedBlocks.set(delKey, true);
const resistencia = Math.random() * 1.5 + 0.5;
setBlockResistanceAt(cx, cz, lx, ly, lz, resistencia);

        // Eliminar del chunk
        const parentChunk = Array.from(loadedChunks.values()).find(c => c.mesh === currentTarget.parent);
        if (parentChunk && parentChunk.blocks?.[lx]?.[ly]?.[lz]) {
          parentChunk.blocks[lx][ly][lz].exists = false;
          parentChunk.blocks[lx][ly][lz].mesh = null;
        }

        // Eliminar del array global
        const idx = terrain.indexOf(currentTarget);
        if (idx !== -1) terrain.splice(idx, 1);

        // Limpieza final
        removeCrackOverlay(currentTarget);
        currentTarget = null;
        breaking = false;
        updateBreakBar(0);
      }
    }
  }

  // 🟩 INSTANCEDMESH
  else if (currentInstance !== null && currentMesh) {
    const distance = camera.position.distanceTo(crackOverlayMesh.position);
    if (distance > maxBreakDistance) {
      breaking = false;
      removeCrackOverlay();
      updateBreakBar(0);
      currentInstance = null;
      currentMesh = null;
    } else {
      const delta = 0.016;
      const now = performance.now();
      const progress = Math.min((now - breakStartTime) / 1000, 1);

      updateBreakBar(progress);
      updateCrackLayer(progress);
updateCrackOverlayInstance(dummy.position, progress, texturesCrack);

      if (progress >= 1) {
        const dummy = new THREE.Object3D();
        dummy.position.set(9999, 9999, 9999);
        dummy.updateMatrix();
        currentMesh.setMatrixAt(currentInstance, dummy.matrix);
        currentMesh.instanceMatrix.needsUpdate = true;

        // Marcar como eliminado en el mapa
        // Buscamos el chunk que contiene este InstancedMesh
        const chunkEntry = Array.from(loadedChunks.entries()).find(([, val]) =>
          val.mesh.children.includes(currentMesh)
        );
        if (chunkEntry) {
          const [key, chunkData] = chunkEntry;
          const [cx, cz] = key.split(",").map(Number);

          // Buscar instancia por matriz
          const dummy = new THREE.Object3D();
          currentMesh.getMatrixAt(currentInstance, dummy.matrix);
          dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

          const lx = Math.floor(dummy.position.x) % CHUNK_SIZE;
          const lz = Math.floor(dummy.position.z) % CHUNK_SIZE;
          const ly = Math.floor(dummy.position.y);
          const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
          deletedBlocks.set(delKey, true);

          if (chunkData.blocks?.[lx]?.[ly]?.[lz]) {
            chunkData.blocks[lx][ly][lz].exists = false;
          }
        }

        removeCrackOverlay();
        updateBreakBar(0);
        currentInstance = null;
        currentMesh = null;
        breaking = false;
      }
    }
  }
}

function limpiarCracksFlotantes() {
  for (const bloque of terrain) {
    const overlay = bloque.userData.crackOverlay;
    if (overlay) {
      // Si el bloque fue eliminado o la grieta no coincide con el bloque
      const posicionIgual = overlay.position.equals(bloque.position);
      if (!scene.children.includes(bloque) || !posicionIgual) {
        removeCrackOverlay(bloque);
      }
    }
  }
}

  // Gravedad y salto
  if (!modoEspectador) {
  // Modo normal (con gravedad)
  const groundCheckOffsets = [
    new THREE.Vector2(0, 0),
    new THREE.Vector2(0.3, 0),
    new THREE.Vector2(-0.3, 0),
    new THREE.Vector2(0, 0.3),
    new THREE.Vector2(0, -0.3)
  ];

  let ground = -Infinity;
  for (let offset of groundCheckOffsets) {
    const gx = player.position.x + offset.x;
    const gz = player.position.z + offset.y;
    const h = getGroundHeight(gx, gz);
    if (h > ground) ground = h;
  }

  const jumpMax = ground + 0.45 + salto;

  if ((player.position.y < jumpMax && velocityY > 0) || player.position.y > ground + 0.45) {
    velocityY -= gravedad;
    onGround = false;
  } else {
    if (player.position.y >= jumpMax) {
      velocityY = Math.min(velocityY, 0);
      player.position.y = jumpMax;
    } else {
      velocityY = 0;
      player.position.y = ground + 0.45;
      onGround = true;
    }
  }

  player.position.y += velocityY;
} else {
  // 👻 Modo espectador: subir/bajar libremente
  if (jumpPressed) {
    player.position.y += 0.15;
  }
  if (bajando) {
    player.position.y -= 0.15;
  }
}

if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const delta = 0.016; // tiempo entre frames (aprox 60fps)
  const data = currentTarget.userData;
  data.currentBreak += delta;

  const progress = data.currentBreak / data.resistance;
  updateBreakBar(progress); // Actualizar barra de rompimiento

  if (data.currentBreak >= data.resistance) {
  if (currentTarget.parent) {
    currentTarget.parent.remove(currentTarget);
  }
  const worldPos = currentTarget.position;
const cx = Math.floor(worldPos.x / CHUNK_SIZE);
const cz = Math.floor(worldPos.z / CHUNK_SIZE);
const lx = Math.floor(worldPos.x) % CHUNK_SIZE;
const lz = Math.floor(worldPos.z) % CHUNK_SIZE;
const ly = Math.floor(worldPos.y);
const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
deletedBlocks.set(delKey, true);

  // Eliminar de los datos del chunk
const parentChunk = Array.from(loadedChunks.values()).find(c => c.mesh === currentTarget.parent);
if (parentChunk) {
  for (let lx in parentChunk.blocks) {
    for (let y in parentChunk.blocks[lx]) {
      for (let lz in parentChunk.blocks[lx][y]) {
        const b = parentChunk.blocks[lx][y][lz];
        if (b.mesh === currentTarget) {
          parentChunk.blocks[lx][y][lz].exists = false;
          parentChunk.blocks[lx][y][lz].mesh = null;
        }
      }
    }
  }
}

  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);
  removeCrackOverlay(currentTarget);
  currentTarget = null;
  breaking = false;
  updateBreakBar(0);


  }
} else {
  updateBreakBar(0); // Ocultar barra si no está rompiendo
}

if (camMode === 0) {
  // 1ra persona (como tu versión)
  const eyeOffset = new THREE.Vector3(0, 0., 0);
  const camOffset = eyeOffset.clone();

  if (breaking && currentTarget && terrain.includes(currentTarget)) {
    const delta = 0.016; // aprox 60fps
    const data = currentTarget.userData;
    data.currentBreak += delta;

    const progress = data.currentBreak / data.resistance;
    updateBreakBar(progress);

    if (data.currentBreak >= data.resistance) {
  if (currentTarget.parent) {
    currentTarget.parent.remove(currentTarget);
  }
  const worldPos = currentTarget.position;
const cx = Math.floor(worldPos.x / CHUNK_SIZE);
const cz = Math.floor(worldPos.z / CHUNK_SIZE);
const lx = Math.floor(worldPos.x) % CHUNK_SIZE;
const lz = Math.floor(worldPos.z) % CHUNK_SIZE;
const ly = Math.floor(worldPos.y);
const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
deletedBlocks.set(delKey, true);

  // Eliminar de los datos del chunk
const parentChunk = Array.from(loadedChunks.values()).find(c => c.mesh === currentTarget.parent);
if (parentChunk) {
  for (let lx in parentChunk.blocks) {
    for (let y in parentChunk.blocks[lx]) {
      for (let lz in parentChunk.blocks[lx][y]) {
        const b = parentChunk.blocks[lx][y][lz];
        if (b.mesh === currentTarget) {
          parentChunk.blocks[lx][y][lz].exists = false;
          parentChunk.blocks[lx][y][lz].mesh = null;
        }
      }
    }
  }
}

  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);
  removeCrackOverlay(currentTarget);
  currentTarget = null;
  breaking = false;
  updateBreakBar(0);
}

  } else {
    updateBreakBar(0);
  }

  const quat = new THREE.Quaternion().setFromEuler(new THREE.Euler(camPitch, camYaw, 0, 'YXZ'));
  camOffset.applyQuaternion(quat);

  camera.position.copy(player.position).add(camOffset);
  camera.rotation.set(camPitch, camYaw, 0, 'YXZ');
} 
else {
  // 3ra y 2da persona
  const target = player.position.clone();
  target.y += 1;

  let offset;
  if (camMode === 1) {
    // 3ra persona (detrás)
    offset = new THREE.Vector3(0, 2, -3);

  } else {
    // 2da persona (diagonal frontal)
    // Más lejos y un poco más alto
offset = new THREE.Vector3(0, 2, -3);


  }

  offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), camPitch);
  offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), camYaw);

  const idealCamPos = player.position.clone().add(offset);

  const rayDir = idealCamPos.clone().sub(target).normalize();
  const raycaster = new THREE.Raycaster(target, rayDir, 0, offset.length());

  const intersects = raycaster.intersectObjects(terrain, false);

  if (intersects.length > 0) {
    camera.position.lerp(intersects[0].point, 0.2);
  } else {
    camera.position.lerp(idealCamPos, 0.2);
  }

  camera.lookAt(target);

  player.rotation.y = camMode === 2 ? camYaw + Math.PI : camYaw;
}


  dibujarDebugColisiones();

  renderer.render(scene, camera);
}


updateChunksAroundPlayer();
setInterval(updateChunksAroundPlayer, 1000); // actualiza cada segundo
posicionarJugadorInicial();

setInterval(() => {
  if (!modoEspectador) actualizarBloquesFisicos();
}, 250);

animate();



</script>

</body>
</html>
