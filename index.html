<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>cubox</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
<style>
  body { margin: 0; overflow: hidden;
  font-family: 'Press Start 2P', cursive;touch-action: none; background:#87CEEB; }
  

 #joystick {
  position: absolute; bottom: 30px; left: 30px;
  width: 100px; height: 100px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid #888;
  image-rendering: pixelated;
}

  #joystick > div {
    position: absolute;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.7);
    
    pointer-events: none;
    left: 35px;
    top: 35px;
  }
 #pause-button {
  position: absolute;
  top: 1px;
  left: 50%;
  transform: translateX(-50%);
  width: 30px;
  height: 30px;
  background-color: #222;
  color: #fff;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#shadow-toggle {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  width: 140px;
  height: 40px;
  background-color: #444;
  color: white;
  font-size: 14px;
  text-align: center;
  line-height: 40px;
  
  z-index: 20;
  cursor: pointer;
}
#shadow-toggle.on {
  background-color: #27ae60;
}

#pause-menu {
  position: absolute;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  backdrop-filter: blur(10px);
  background-color: rgba(0,0,0,0.4);
  z-index: 30;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.pause-option {
  width: 160px;
  margin: 10px;
  padding: 12px;
  background: #333;
  color: white;
  font-size: 18px;
  text-align: center;
  
  cursor: pointer;
}
#collision-toggle.on {
  background-color: #27ae60 !important;
}

#jump-button {
  position: absolute;
  bottom: 59px;
  right: 50px;
  width: 34px;
  height: 34px;
  background-color: #3c3c3c;
  border: 4px solid #fff;
  box-shadow: inset -4px -4px 0 #1a1a1a, inset 4px 4px 0 #666;
  image-rendering: pixelated;
  cursor: pointer;
  border-radius: 0%;
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#camera-toggle {
position: absolute;
top: 10px;
right: 10px;
width: 50px;
height: 40px;
background-color: #222;
color: #e0e0e0;
font-size: 9px;
font-weight: 600;
text-align: center;
line-height: 40px;

box-shadow: 0 2px 5px rgba(0,0,0,0.4);
user-select: none;
cursor: pointer;
transition: background-color 0.25s ease, color 0.25s ease;
z-index: 10;
}
#camera-toggle\:hover {
background: #666;
color: #fff;
}
#camera-toggle\:active {
background: #444;
color: #ccc;
}

  #crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin-left: -10px;
  margin-top: -10px;
  pointer-events: none;
  z-index: 15;
}
#crosshair:before, #crosshair:after {
  content: '';
  position: absolute;
  background: rgba(0, 0, 0, 0.5); /* negro semi-transparente */
}
#crosshair:before {
  left: 9px;
  top: 0;
  width: 2px;
  height: 20px;
}
#crosshair:after {
  top: 9px;
  left: 0;
  width: 20px;
  height: 2px;
}
.pause-option.on {
  background-color: #4caf50;
  color: white;
}

 #pri-button {
  position: absolute;
  top: 100px;
  right: 10px;
  width: 64px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.5); /* gris transl√∫cido */
  border: 2px solid white; /* borde blanco */
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  z-index: 10;
  user-select: none;
  touch-action: none;
}

  #slide-panel {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: #222;
  color: white;
  padding: 20px;
  box-shadow: -3px 0 10px rgba(0,0,0,0.7);
  transition: right 0.3s ease;
  z-index: 50;
  display: flex;
  flex-direction: column;
}

#slide-panel.open {
  right: 0;
}

#close-panel-btn {
  align-self: flex-end;
  font-size: 24px;
  cursor: pointer;
  user-select: none;
}
#start-panel {
  position: fixed;
  inset: 0;
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#play-button {
  font-family: 'Press Start 2P', monospace;
  font-size: 16px;
  padding: 16px 32px;
  border: 3px solid #fff;
  background-color: #222;
  color: #0f0;
  cursor: pointer;
  box-shadow: 0 0 5px #0f0;
  image-rendering: pixelated;
  text-shadow: 1px 1px 0 #000;
}

#play-button:active {
  transform: scale(0.95);
}
#pantalla-carga {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.bloque-contenedor {
  display: flex;
  gap: 20px;
  animation: rotar 2s infinite ease-in-out;
}

.bloque {
  width: 64px;
  height: 64px;
  background-size: cover;
  border: 2px solid white;
}

.bloque.tierra  { background-image: url('Texturas/interiordetronco.png'); }
.bloque.cesped  { background-image: url('Texturas/cesped_parte_costado.jpg'); }
.bloque.piedra  { background-image: url('Texturas/piedra.jpg'); }

#texto-carga {
  margin-top: 40px;
  color: white;
  font-family: 'Press Start 2P', monospace;
  font-size: 12px;
}

@keyframes rotar {
  0% { transform: rotate(0deg); }
  50% { transform: rotate(3deg); }
  100% { transform: rotate(-3deg); }
}

/* Fuente pixel */
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
</style>
</head>
<body>
  <div id="pantalla-carga">
  <div class="bloque-contenedor">
    <div class="bloque tierra"></div>
    <div class="bloque cesped"></div>
    <div class="bloque piedra"></div>
  </div>
  <div id="texto-carga">cargando</div>
  <div id="tip-carga" style="margin-top: 20px; color: #ccc; font-size: 10px; font-family: 'Press Start 2P', monospace; text-align: center; max-width: 90%; line-height: 1.5; cursor: pointer;">
   Usa el joystick para moverte.
</div>

</div>

  <div id="start-panel">
  <button id="play-button">JUGAR</button>
</div>
<div id="break-bar-container" style="position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 5px; border: 2px solid white; display: none;">
  <div id="break-bar" style="background: white; width: 0%; height: 100%;"></div>
</div>

<div id="pause-button"><i class="fas fa-pause"></i></div>


<div id="pause-menu">
  <div class="pause-option" id="resume-btn"><i class="fas fa-play"></i> Reanudar</div>
<div id="open-panel-btn" class="pause-option"><i class="fas fa-cog"></i> Ajustes</div>


<div id="slide-panel">
  <div id="close-panel-btn">√ó</div>
  <!-- Contenido del panel -->
<div style="margin-top: 200px;">
  <label for="render-distance-slider" style="display: block; font-size: 14px;">Distancia de renderizado: <span id="render-distance-value">1</span></label>
  <input type="range" id="render-distance-slider" min="1" max="10" value="1" step="1" style="width: 100%;">
</div>
<div id="spectator-toggle" class="pause-option" style="position: absolute;font-size: 10px; top: 300px; left: 50%; transform: translateX(-50%); width: 200px;">Espectador: OFF</div>


    <div id="shadow-toggle">Sombras: OFF</div>
</div>



 

  <div id="settings-menu" style="display:none; flex-direction: column; align-items: center; justify-content: center; height: 100vh; width: 100vw; position: absolute; top: 0; left: 0; backdrop-filter: blur(10px); background-color: rgba(0,0,0,0.4); z-index: 40;">
  <div class="pause-option" id="back-btn">üîô Volver</div>
  <!-- Aqu√≠ luego agregas tus controles de ajustes -->
</div>

</div>

<div id="joystick"><div id="joystick-thumb"></div></div>
<div id="jump-button"></div>
<div id="camera-toggle">1ra </div>
<div id="pri-button">pri</div>

<div id="crosshair"></div>

<script>
// Setup b√°sico
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Funci√≥n para redimensionar correctamente
function resizeCanvas() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
}

// Eventos para detectar rotaci√≥n o cambio de tama√±o
window.addEventListener('resize', resizeCanvas);
screen.orientation?.addEventListener("change", resizeCanvas);
document.addEventListener("fullscreenchange", resizeCanvas);

// Llamar al inicio por si ya est√° en horizontal
resizeCanvas();


document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const cameraHolder = new THREE.Object3D();
scene.add(cameraHolder);
cameraHolder.add(camera);

const loader = new THREE.TextureLoader();
loader.load('Texturas/dia.jpg', function(texture) {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
});

// Luz
scene.background = new THREE.Color(0xffffff);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(10,20,10);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
scene.add(dirLight);
const renderDistanceSlider = document.getElementById("render-distance-slider");
const renderDistanceValue = document.getElementById("render-distance-value");

renderDistanceSlider.addEventListener("input", () => {
  RENDER_DISTANCE = parseInt(renderDistanceSlider.value);
  renderDistanceValue.textContent = RENDER_DISTANCE;
  updateChunksAroundPlayer(); // fuerza una actualizaci√≥n inmediata
});
let modoEspectador = false;
let bajando = false;
let dobleToqueTiempo = 0;

const salto = 1; // altura de salto en bloques
const gravedadBase = 0.02;
const gravedad = gravedadBase * salto;  // mayor salto = m√°s gravedad para mantener tiempos similares

const texturaGrieta = loader.load('/Texturas/crack.png');
texturaGrieta.wrapS = THREE.RepeatWrapping;
texturaGrieta.wrapT = THREE.RepeatWrapping;


// Terreno b√°sico con bloques
const simplex = new SimplexNoise();
const blockSize = 1;
const worldSize = 10;
let terrain = [];
let joystickTouchId = null;
let cameraTouchId = null;

const textureLoader = new THREE.TextureLoader();
const texturesCrack = [
  textureLoader.load('Texturas/crack1.png'),
  textureLoader.load('Texturas/crack2.png'),
  textureLoader.load('Texturas/crack3.png'),
  textureLoader.load('Texturas/crack4.png'),
  textureLoader.load('Texturas/crack5.png'),
];

const textures = {
  grass_top: textureLoader.load("Texturas/cesped.jpg"),
  grass_side: textureLoader.load("Texturas/cesped_parte_costado.jpg"),
  dirt: textureLoader.load("Texturas/tierra.jpg"),
  stone: textureLoader.load("Texturas/piedra.jpg"),
  crack: textureLoader.load("Texturas/crack.png") // ‚Üê se a√±adi√≥ aqu√≠
};
const panel = document.getElementById("start-panel");
const button = document.getElementById("play-button");

async function goFullscreenLandscape() {
  try {
    // Fullscreen
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    
    // Orientaci√≥n horizontal
    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientaci√≥n:", e);
  }
  async function goFullscreenLandscape() {
  try {
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();

    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");

    resizeCanvas(); // Asegura que se actualice al instante
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientaci√≥n:", e);
  }

  panel.style.display = "none";
}

  // Ocultar panel
  panel.style.display = "none";
}

// Mostrar el panel si se sali√≥ de fullscreen u orientaci√≥n
function checkState() {
  const isFull = !!document.fullscreenElement;
  const isLandscape = screen.orientation?.type?.includes("landscape");
  
  if (!isFull || !isLandscape) {
    panel.style.display = "flex";
  }
}

button.addEventListener("click", goFullscreenLandscape);
document.addEventListener("fullscreenchange", checkState);
screen.orientation?.addEventListener("change", checkState);

// Tambi√©n se comprueba al rotar el dispositivo
window.addEventListener("resize", checkState);
const jumpButton = document.getElementById("jump-button");

function createBlock(x, y, z, type) {
  const textureMaps = (() => {
    if(type === "grass") {
      return [
        textures.grass_side,
        textures.grass_side,
        textures.grass_top,
        textures.dirt,
        textures.grass_side,
        textures.grass_side
      ];
    } else if(type === "dirt") {
      return new Array(6).fill(textures.dirt);
    } else if(type === "stone") {
      return new Array(6).fill(textures.stone);
    }
  })();

  const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
  const materials = [];

  for(let i = 0; i < 6; i++) {
    materials.push(new THREE.MeshStandardMaterial({ map: textureMaps[i] }));
  }

  const block = new THREE.Mesh(geometry, materials);

  block.userData = {
    type: type,
    resistance: type === "stone" ? 3 : type === "dirt" ? 1.5 : 1,
    currentBreak: 0,
    crackMaterial: null
  };

  block.castShadow = true;
block.receiveShadow = true;
block.position.set(x * blockSize, y * blockSize, z * blockSize);

// scene.add(block); ‚Üê esto debe estar eliminado
// terrain.push(block); ‚Üê esto lo hacemos en generateChunk
return block; // ‚úÖ

}
function actualizarVisibilidadGlobal() {
  const dirs = [
    new THREE.Vector3(1, 0, 0),
    new THREE.Vector3(-1, 0, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, -1, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(0, 0, -1),
  ];

  for (const bloque of terrain) {
    const pos = bloque.position.clone().divideScalar(blockSize);

    const estaRodeado = dirs.every(dir => {
      const neighborPos = pos.clone().add(dir);
      return terrain.some(b =>
        b.position.x === neighborPos.x * blockSize &&
        b.position.y === neighborPos.y * blockSize &&
        b.position.z === neighborPos.z * blockSize
      );
    });

    bloque.visible = !estaRodeado;
  }
}
const deletedBlocks = new Map(); // clave: \"chunkKey|x,y,z\" ‚Üí true
const tips = [
  "el lag es parte del juego",
  "ten paciencia ",
  "usa [pri] para romper o golpear",
  "con [sec] puedes poner bloques o usar algo",
  "Cambia la distancia de renderizado en ajustes.",
  "Explora, construye y destruye como quieras.",
  "Puedes activar o desactivar sombras.",
  "Toca dos veces salto para bajar en espectador.",
  "Explora, construye y destruye como quieras.",
  "Usa el joystick para moverte en cualquier direcci√≥n.",
  "Presiona el bot√≥n para saltar obst√°culos.",
  "Mant√©n presionado para romper bloques.",
  "Cambia entre 1ra, 2da y 3ra persona tocando el bot√≥n de c√°mara.",
  "Activa el modo espectador para volar por el mundo.",
  "Puedes atravesar paredes en modo espectador.",
  "Toca dos veces salto para bajar mientras vuelas.",
  "Modifica la distancia de renderizado desde el men√∫ de pausa.",
  "Activa o desactiva sombras para mejorar el rendimiento.",
  "Los bloques de piedra son m√°s resistentes.",
  "Solo puedes romper bloques si est√°s cerca.",
  "No todos los bloques necesitan romperse para explorar.",
  "Al√©jate para que los chunks lejanos se descarguen.",
  "Cuidado: los bloques no flotan solos por mucho tiempo.",
  "Personaliza los controles desde el panel de ajustes.",
  "Descubre cuevas ocultas bajo tierra.",
  "Construye escaleras o torres con bloques que t√∫ pongas.",
  "Experimenta con distintas vistas para explorar mejor.",
  "Tienes el control total del mundo: ¬°s√© creativo!"

];

const tipDiv = document.getElementById("tip-carga");
let tipsMostrados = [];
let tipIndex = 0;
let tipTimer = null;

function mostrarSiguienteTip() {
  if (tipsMostrados.length === tips.length) {
    tipsMostrados = []; // reset si ya se mostraron todos
  }

  let nuevoTip;
  do {
    tipIndex = Math.floor(Math.random() * tips.length);
    nuevoTip = tips[tipIndex];
  } while (tipsMostrados.includes(nuevoTip));

  tipsMostrados.push(nuevoTip);
  tipDiv.textContent = " " + nuevoTip;

  reiniciarTemporizador();
}

function reiniciarTemporizador() {
  clearTimeout(tipTimer);
  tipTimer = setTimeout(mostrarSiguienteTip, 5000);
}

// Cambiar tip si se hace clic
tipDiv.addEventListener("click", mostrarSiguienteTip);

// Iniciar el primer tip
mostrarSiguienteTip();

const CHUNK_SIZE = 5;
let RENDER_DISTANCE = 1; // ‚úÖ para poder modificarla con el slider

const loadedChunks = new Map();

function generateChunk(cx, cz) {
  const key = `${cx},${cz}`;
  if (loadedChunks.has(key)) return;

  const group = new THREE.Group();
  group.name = `chunk_${cx}_${cz}`;

  const blocks = {}; // estructura para guardar los bloques del chunk

  for (let x = 0; x < CHUNK_SIZE; x++) {
    for (let z = 0; z < CHUNK_SIZE; z++) {
      const worldX = cx * CHUNK_SIZE + x;
      const worldZ = cz * CHUNK_SIZE + z;

      const n = simplex.noise2D(worldX / 10, worldZ / 10);
      const height = Math.floor((n + 1) * 5);

      for (let y = 0; y < height; y++) {
        let type = "stone";
        if (y === height - 1) type = "grass";
        else if (y >= height - 3) type = "dirt";

        const lx = x;
        const lz = z;
        const delKey = `${cx},${cz}|${lx},${y},${lz}`;
        if (deletedBlocks.has(delKey)) continue; // no crear si fue destruido

        const block = createBlock(worldX, y, worldZ, type);
        group.add(block);
        terrain.push(block); // necesario para raycasting y colisiones

        // guardar bloque en estructura local
        if (!blocks[lx]) blocks[lx] = {};
        if (!blocks[lx][y]) blocks[lx][y] = {};
        blocks[lx][y][lz] = {
          mesh: block,
          type: type,
          exists: true
        };
      }
    }
  }

  scene.add(group);
  loadedChunks.set(key, {
    mesh: group,
    blocks: blocks
  });
}

setTimeout(() => {
  const pantalla = document.getElementById("pantalla-carga");
  if (pantalla) pantalla.style.display = "none";
  console.log("‚è≥ Pantalla de carga oculta tras 30 segundos.");
}, 30000); // ‚Üê Cambia este valor si quieres otro tiempo

function updateChunksAroundPlayer() {
  const px = Math.floor(player.position.x / CHUNK_SIZE);
  const pz = Math.floor(player.position.z / CHUNK_SIZE);

  const seen = new Set();
  const chunksToGenerate = [];

  for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
    for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
      const cx = px + dx;
      const cz = pz + dz;
      const key = `${cx},${cz}`;
      seen.add(key);
      if (!loadedChunks.has(key)) {
        chunksToGenerate.push([cx, cz]); // Solo los no cargados
      }
    }
  }
const textoCarga = document.getElementById("texto-carga");
let puntos = 0;
setInterval(() => {
  puntos = (puntos + 1) % 4;
  textoCarga.textContent = "cargando" + ".".repeat(puntos);
}, 1000);

  // Cargar lentamente, uno cada 50ms
  chunksToGenerate.forEach(([cx, cz], index) => {
  setTimeout(() => {
    generateChunk(cx, cz);
  }, index * 500); // ‚¨ÖÔ∏è Aumentado de 50 a 200ms
});


  // Eliminar chunks fuera del rango
  for (let key of loadedChunks.keys()) {
    if (!seen.has(key)) {
      const chunk = loadedChunks.get(key);
      scene.remove(chunk.mesh);
      loadedChunks.delete(key);
    }
  }
}

setInterval(actualizarVisibilidadGlobal, 100);


const faceTexture = loader.load('Texturas/cub.png');

const materials = [
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara derecha
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara izquierda
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara arriba
  new THREE.MeshStandardMaterial({ color: 0x0000ff }), // cara abajo
  new THREE.MeshStandardMaterial({ map: faceTexture }), // cara frontal (z positiva)
  new THREE.MeshStandardMaterial({ color: 0x0000ff })  // cara trasera
];

const playerGeometry = new THREE.BoxGeometry(0.8, 0.9, 0.8);
const player = new THREE.Mesh(playerGeometry, materials);
player.castShadow = true;
player.receiveShadow = true;
scene.add(player);



const raycaster = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);
function hayEspacioParaSaltar() {
  const start = player.position.clone().add(new THREE.Vector3(0, 0.5, 0));
  const dir = new THREE.Vector3(0, 1, 0);
  raycaster.ray.origin.copy(start);
  raycaster.ray.direction.copy(dir);

  const intersects = raycaster.intersectObjects(terrain, false);
  for (const hit of intersects) {
    if (hit.distance <= 0.9) return false; // solo bloquea si el obst√°culo est√° a 1.1 o menos
  }

  return true;
}
// L√≠neas de colisi√≥n y raycaster
const debugLines = [];
function dibujarDebugColisiones() {
  debugLines.forEach(line => scene.remove(line));
  debugLines.length = 0;

  if (!mostrarColisiones) return;

  const offsets = [
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0.3, 0, 0),
    new THREE.Vector3(-0.3, 0, 0),
    new THREE.Vector3(0, 0, 0.3),
    new THREE.Vector3(0, 0, -0.3)
  ];

  for (let offset of offsets) {
    const start = player.position.clone().add(offset).setY(player.position.y);
    const end = start.clone();
    end.y -= 3;

    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    debugLines.push(line);
  }

  const rayStart = new THREE.Vector3(player.position.x, 50, player.position.z);
  const rayEnd = rayStart.clone().add(down.clone().multiplyScalar(50));
  const rayGeom = new THREE.BufferGeometry().setFromPoints([rayStart, rayEnd]);
  const rayLine = new THREE.Line(rayGeom, new THREE.LineBasicMaterial({ color: 0xffff00 }));
  scene.add(rayLine);
  debugLines.push(rayLine);
}

function getGroundHeight(x, z) {
  raycaster.ray.origin.set(x, player.position.y + 1, z); // o +1.5 para margen
  raycaster.ray.direction.copy(down);
  const hits = raycaster.intersectObjects(terrain);
  if (hits.length > 0) return hits[0].point.y;
  return 0;
}


player.position.set(8, 30, 8); // 30 para asegurarte de que cae al suelo generado

player.position.y = getGroundHeight(player.position.x, player.position.z)+0.45;
const pauseBtn = document.getElementById("pause-button");
const pauseMenu = document.getElementById("pause-menu");
const resumeBtn = document.getElementById("resume-btn");

let sombrasActivas = false; // Estado inicial: desactivadas
const spectatorToggle = document.getElementById("spectator-toggle");

spectatorToggle.addEventListener("click", () => {
  modoEspectador = !modoEspectador;
  spectatorToggle.textContent = "Espectador: " + (modoEspectador ? "ON" : "OFF");
  spectatorToggle.classList.toggle("on", modoEspectador);
});

const shadowToggle = document.getElementById("shadow-toggle");
const updateSombras = () => {
  dirLight.castShadow = sombrasActivas;

  scene.traverse(obj => {
    if (obj.isMesh) {
      obj.castShadow = sombrasActivas;
      obj.receiveShadow = sombrasActivas;
    }
  });

  shadowToggle.textContent = sombrasActivas ? "Sombras: ON" : "Sombras: OFF";
  shadowToggle.classList.toggle("on", sombrasActivas);
};
const openBtn = document.getElementById('open-panel-btn');
const slidePanel = document.getElementById('slide-panel');
const closeBtn = document.getElementById('close-panel-btn');

openBtn.addEventListener('click', () => {
  slidePanel.classList.add('open');
});

closeBtn.addEventListener('click', () => {
  slidePanel.classList.remove('open');
});


const showDebugBtn = document.createElement('div');
showDebugBtn.id = 'collision-toggle';
showDebugBtn.textContent = 'Colisiones: OFF';
showDebugBtn.style.position = 'absolute';
showDebugBtn.style.top = '140px';
showDebugBtn.style.left = '50%';
showDebugBtn.style.transform = 'translateX(-50%)';
showDebugBtn.style.width = '180px';
showDebugBtn.style.height = '40px';
showDebugBtn.style.backgroundColor = '#444'; // Se sobreescribe por .on
showDebugBtn.style.color = 'white';
showDebugBtn.style.fontSize = '14px';
showDebugBtn.style.textAlign = 'center';
showDebugBtn.style.lineHeight = '40px';
showDebugBtn.style.zIndex = '20';
showDebugBtn.style.cursor = 'pointer';

let colisionesActivas = false;

showDebugBtn.onclick = () => {
  colisionesActivas = !colisionesActivas;
  showDebugBtn.textContent = colisionesActivas ? "Colisiones: ON" : "Colisiones: OFF";
  showDebugBtn.classList.toggle("on", colisionesActivas);
};

slidePanel.appendChild(showDebugBtn);


let mostrarColisiones = false;
showDebugBtn.addEventListener('click', () => {
  mostrarColisiones = !mostrarColisiones;
  showDebugBtn.textContent = mostrarColisiones ? 'Colisiones: ON' : 'Colisiones: OFF';
  // aqu√≠ llamar√≠as a la funci√≥n que muestra/oculta las colisiones
});

// Palanca
shadowToggle.addEventListener("click", () => {
  sombrasActivas = !sombrasActivas;
  updateSombras();
});

// Aplicar sombras al iniciar (est√°n apagadas)
updateSombras();

let paused = false;

pauseBtn.addEventListener("click", () => {
  paused = true;
  pauseMenu.style.display = "flex";
});

resumeBtn.addEventListener("click", () => {
  paused = false;
  pauseMenu.style.display = "none";
});




// Variables para joystick
const joystick = document.getElementById("joystick");
const thumb = joystick.children[0];
let joystickActive = false;
let joystickStart = {x:0,y:0};
let moveVector = new THREE.Vector2(0,0);

joystick.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (joystickTouchId === null) {
      joystickTouchId = touch.identifier;
      joystickActive = true;
      joystickStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId && joystickActive) {
      const deltaX = (touch.clientX - joystickStart.x) / 50;
      const deltaY = (touch.clientY - joystickStart.y) / 50;
      moveVector.set(
        Math.max(-1, Math.min(1, deltaX)),
        Math.max(-1, Math.min(1, deltaY))
      );
      thumb.style.left = 35 + moveVector.x * 30 + "px";
      thumb.style.top  = 35 + moveVector.y * 30 + "px";
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      joystickTouchId = null;
      joystickActive = false;
      moveVector.set(0, 0);
      thumb.style.left = "35px";
      thumb.style.top  = "35px";
      e.preventDefault();
      break;
    }
  }
});

// Variables para control de c√°mara con swipe
let camYaw = 0;
let camPitch = 0;
const camDistance = 5;
let looking = false;
let lookStart = {x:0,y:0};

function isTouchOnJoystick(touch){
  const r = joystick.getBoundingClientRect();
  return (touch.clientX>=r.left && touch.clientX<=r.right && touch.clientY>=r.top && touch.clientY<=r.bottom);
}

renderer.domElement.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (!isTouchOnJoystick(touch) && cameraTouchId === null) {

      cameraTouchId = touch.identifier;
      looking = true;
      lookStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId && looking) {
      if (isTouchOnJoystick(touch)) return;
      const dx = touch.clientX - lookStart.x;
      const dy = touch.clientY - lookStart.y;
      lookStart.x = touch.clientX;
      lookStart.y = touch.clientY;
      camYaw   -= dx * 0.005;
      camPitch -= dy * 0.005;
      const maxP = Math.PI / 2 - 0.1;
      const minP = -maxP;
      camPitch = Math.max(minP, Math.min(maxP, camPitch));
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId) {
      cameraTouchId = null;
      looking = false;
      e.preventDefault();
      break;
    }
  }
});

const jumpSpeed = 0.23;
let velocityY = 0;
let onGround = false;
let jumpPressed = false;


function jump(){
  if (onGround && hayEspacioParaSaltar()) {
    velocityY = jumpSpeed;
    onGround = false;
  }
}

jumpButton.addEventListener("touchstart", e => {
  e.preventDefault();

  const now = performance.now();
  if (modoEspectador && now - dobleToqueTiempo < 400) {
    bajando = true;
  } else {
    dobleToqueTiempo = now;
    jumpPressed = true;
    if (!modoEspectador) jump();
  }
});

jumpButton.addEventListener("touchend", e => {
  e.preventDefault();
  jumpPressed = false;
  bajando = false;
});


let camMode = 0; // 0 = 1ra, 1 = 3ra, 2 = 2da

const camToggleBtn = document.getElementById("camera-toggle");
camToggleBtn.addEventListener("click", () => {
  camMode = (camMode + 1) % 3;
  const labels = ["1ra", "2da", "3ra"];
  camToggleBtn.textContent = ` ${labels[camMode]}`;
  player.visible = camMode !== 0;
});

// Funci√≥n animaci√≥n y l√≥gica
const moveSpeed = 0.3;
const priButton = document.getElementById("pri-button");

let breaking = false;
let currentTarget = null;
let breakStartTime = 0;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const intersects = raycaster.intersectObjects(terrain);
  if (intersects.length > 0) {
    currentTarget = intersects[0].object;
    breakStartTime = performance.now();
    breaking = true;
  }
});

priButton.addEventListener("touchend", () => {
  breaking = false;
  if (currentTarget) {
    removeCrackOverlay(currentTarget);
    currentTarget.userData.currentBreak = 0;
    currentTarget = null;
  }
});

function addCrackLayer(block, index) {
  if (block.userData.crackOverlay) {
    block.userData.crackOverlay.material.map = texturesCrack[index];
    block.userData.crackOverlay.material.needsUpdate = true;
    return;
  }

  const crackTexture = texturesCrack[index];

  const crackMaterial = new THREE.MeshBasicMaterial({
    map: crackTexture,
    transparent: true,
    depthTest: true,
    depthWrite: false,
  });

  const crackMesh = new THREE.Mesh(block.geometry.clone(), crackMaterial);
  crackMesh.position.set(0, 0, 0); // relativo al bloque
  crackMesh.rotation.set(0, 0, 0);
  crackMesh.scale.set(1, 1, 1);
  crackMesh.renderOrder = 999;

  block.add(crackMesh);
  block.userData.crackOverlay = crackMesh;
}

function updateCrackLayer(block, progress) {
  const index = Math.min(Math.floor(progress * texturesCrack.length), texturesCrack.length - 1);

  if (!block.userData.crackOverlay) {
    addCrackLayer(block, index);
  } else {
    block.userData.crackOverlay.material.map = texturesCrack[index];
    block.userData.crackOverlay.material.needsUpdate = true;
  }
}

function removeCrackOverlay(block) {
  const overlay = block.userData.crackOverlay;
  if (overlay) {
    block.remove(overlay);
    if (overlay.geometry) {
      overlay.geometry.dispose();
      overlay.geometry = null;
    }
    if (overlay.material) {
      overlay.material.dispose();
      overlay.material = null;
    }
    block.userData.crackOverlay = null;
  }
  // (resto igual)
}

const maxBreakDistance = 6;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const intersects = raycaster.intersectObjects(terrain);
  if (intersects.length > 0) {
    const target = intersects[0].object;
    const distance = camera.position.distanceTo(target.position);
    if (distance <= maxBreakDistance) {
      currentTarget = target;
      breakStartTime = performance.now();
      breaking = true;
    }
  }
});

function animate() {
  requestAnimationFrame(animate);
  const enableStepUp = false;
const breakBarContainer = document.getElementById('break-bar-container');
const breakBar = document.getElementById('break-bar');

function updateBreakBar(progress) {
  if (progress > 0 && progress < 1) {
    breakBarContainer.style.display = 'block';
    breakBar.style.width = (progress * 100) + '%';
  } else {
    breakBarContainer.style.display = 'none';
    breakBar.style.width = '0%';
  }
}

  // Movimiento relativo a la c√°mara
  if (moveVector.lengthSq() > 0.01) {
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();

    const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

    const moveDir = new THREE.Vector3();
    moveDir.addScaledVector(camDir, -moveVector.y);
    moveDir.addScaledVector(camRight, moveVector.x);
    moveDir.normalize();

    const moveStep = moveDir.clone().multiplyScalar(moveSpeed);

    const playerRadius = 0.3;
const playerHeight = 0.9;

    const stepHeight = 0.1;

    // üëá NUEVO: deslizamiento por separado en X y Z
    const moveX = new THREE.Vector3(moveStep.x, 0, 0);
    const moveZ = new THREE.Vector3(0, 0, moveStep.z);

    const yOffsets = [0, 0.4, 0.8];


    let canMoveX = true;
    let canMoveZ = true;

    // Comprobar colisi√≥n en X
    for (let yOffset of yOffsets) {
      const pos = player.position.clone().add(moveX);
      pos.y += yOffset;

      const offsets = [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ];

      let collision = false;
      for (let offset of offsets) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.45) {
          collision = true;
        }
      }
      if (collision) canMoveX = false;
    }

    // Comprobar colisi√≥n en Z
    for (let yOffset of yOffsets) {
      const pos = player.position.clone().add(moveZ);
      pos.y += yOffset;

      const offsets = [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ];

      let collision = false;
      for (let offset of offsets) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.45) {
          collision = true;
        }
      }
      if (collision) canMoveZ = false;
    }

    // Aplicar movimiento permitido para lograr deslizamiento
    if (modoEspectador) {
  player.position.add(moveStep); // üëª atraviesa todo
} else {
  const newPos = player.position.clone().add(moveStep);
  const collisions = terrain.some(obj => {
    const dist = obj.position.distanceTo(newPos);
    return dist < 0.5; // tama√±o del cuerpo del jugador
  });
  if (!collisions) {
    player.position.copy(newPos);
  }
}}


  if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const distance = camera.position.distanceTo(currentTarget.position);
  if (distance > maxBreakDistance) {
    breaking = false;
    removeCrackOverlay(currentTarget);
    currentTarget.userData.currentBreak = 0;
    currentTarget = null;
    updateBreakBar(0);
  } else {
    const delta = 0.016;
    const data = currentTarget.userData;
    data.currentBreak += delta;
    const progress = data.currentBreak / data.resistance;

    updateBreakBar(progress);
    updateCrackLayer(currentTarget, progress); // üëà aplicar textura encima

    if (progress >= 1) {
  if (currentTarget.parent) {
    currentTarget.parent.remove(currentTarget);
  }
  const worldPos = currentTarget.position;
const cx = Math.floor(worldPos.x / CHUNK_SIZE);
const cz = Math.floor(worldPos.z / CHUNK_SIZE);
const lx = Math.floor(worldPos.x) % CHUNK_SIZE;
const lz = Math.floor(worldPos.z) % CHUNK_SIZE;
const ly = Math.floor(worldPos.y);
const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
deletedBlocks.set(delKey, true);

  // Eliminar de los datos del chunk
const parentChunk = Array.from(loadedChunks.values()).find(c => c.mesh === currentTarget.parent);
if (parentChunk) {
  for (let lx in parentChunk.blocks) {
    for (let y in parentChunk.blocks[lx]) {
      for (let lz in parentChunk.blocks[lx][y]) {
        const b = parentChunk.blocks[lx][y][lz];
        if (b.mesh === currentTarget) {
          parentChunk.blocks[lx][y][lz].exists = false;
          parentChunk.blocks[lx][y][lz].mesh = null;
        }
      }
    }
  }
}

  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);
  removeCrackOverlay(currentTarget);
  currentTarget = null;
  breaking = false;
  updateBreakBar(0);
}
}}
function limpiarCracksFlotantes() {
  for (const bloque of terrain) {
    const overlay = bloque.userData.crackOverlay;
    if (overlay) {
      // Si el bloque fue eliminado o la grieta no coincide con el bloque
      const posicionIgual = overlay.position.equals(bloque.position);
      if (!scene.children.includes(bloque) || !posicionIgual) {
        removeCrackOverlay(bloque);
      }
    }
  }
}

  // Gravedad y salto
  if (!modoEspectador) {
  // Modo normal (con gravedad)
  const groundCheckOffsets = [
    new THREE.Vector2(0, 0),
    new THREE.Vector2(0.3, 0),
    new THREE.Vector2(-0.3, 0),
    new THREE.Vector2(0, 0.3),
    new THREE.Vector2(0, -0.3)
  ];

  let ground = -Infinity;
  for (let offset of groundCheckOffsets) {
    const gx = player.position.x + offset.x;
    const gz = player.position.z + offset.y;
    const h = getGroundHeight(gx, gz);
    if (h > ground) ground = h;
  }

  const jumpMax = ground + 0.45 + salto;

  if ((player.position.y < jumpMax && velocityY > 0) || player.position.y > ground + 0.45) {
    velocityY -= gravedad;
    onGround = false;
  } else {
    if (player.position.y >= jumpMax) {
      velocityY = Math.min(velocityY, 0);
      player.position.y = jumpMax;
    } else {
      velocityY = 0;
      player.position.y = ground + 0.45;
      onGround = true;
    }
  }

  player.position.y += velocityY;
} else {
  // üëª Modo espectador: subir/bajar libremente
  if (jumpPressed) {
    player.position.y += 0.15;
  }
  if (bajando) {
    player.position.y -= 0.15;
  }
}

if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const delta = 0.016; // tiempo entre frames (aprox 60fps)
  const data = currentTarget.userData;
  data.currentBreak += delta;

  const progress = data.currentBreak / data.resistance;
  updateBreakBar(progress); // Actualizar barra de rompimiento

  if (data.currentBreak >= data.resistance) {
  if (currentTarget.parent) {
    currentTarget.parent.remove(currentTarget);
  }
  const worldPos = currentTarget.position;
const cx = Math.floor(worldPos.x / CHUNK_SIZE);
const cz = Math.floor(worldPos.z / CHUNK_SIZE);
const lx = Math.floor(worldPos.x) % CHUNK_SIZE;
const lz = Math.floor(worldPos.z) % CHUNK_SIZE;
const ly = Math.floor(worldPos.y);
const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
deletedBlocks.set(delKey, true);

  // Eliminar de los datos del chunk
const parentChunk = Array.from(loadedChunks.values()).find(c => c.mesh === currentTarget.parent);
if (parentChunk) {
  for (let lx in parentChunk.blocks) {
    for (let y in parentChunk.blocks[lx]) {
      for (let lz in parentChunk.blocks[lx][y]) {
        const b = parentChunk.blocks[lx][y][lz];
        if (b.mesh === currentTarget) {
          parentChunk.blocks[lx][y][lz].exists = false;
          parentChunk.blocks[lx][y][lz].mesh = null;
        }
      }
    }
  }
}

  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);
  removeCrackOverlay(currentTarget);
  currentTarget = null;
  breaking = false;
  updateBreakBar(0);


  }
} else {
  updateBreakBar(0); // Ocultar barra si no est√° rompiendo
}

if (camMode === 0) {
  // 1ra persona (como tu versi√≥n)
  const eyeOffset = new THREE.Vector3(0, 0., 0);
  const camOffset = eyeOffset.clone();

  if (breaking && currentTarget && terrain.includes(currentTarget)) {
    const delta = 0.016; // aprox 60fps
    const data = currentTarget.userData;
    data.currentBreak += delta;

    const progress = data.currentBreak / data.resistance;
    updateBreakBar(progress);

    if (data.currentBreak >= data.resistance) {
  if (currentTarget.parent) {
    currentTarget.parent.remove(currentTarget);
  }
  const worldPos = currentTarget.position;
const cx = Math.floor(worldPos.x / CHUNK_SIZE);
const cz = Math.floor(worldPos.z / CHUNK_SIZE);
const lx = Math.floor(worldPos.x) % CHUNK_SIZE;
const lz = Math.floor(worldPos.z) % CHUNK_SIZE;
const ly = Math.floor(worldPos.y);
const delKey = `${cx},${cz}|${lx},${ly},${lz}`;
deletedBlocks.set(delKey, true);

  // Eliminar de los datos del chunk
const parentChunk = Array.from(loadedChunks.values()).find(c => c.mesh === currentTarget.parent);
if (parentChunk) {
  for (let lx in parentChunk.blocks) {
    for (let y in parentChunk.blocks[lx]) {
      for (let lz in parentChunk.blocks[lx][y]) {
        const b = parentChunk.blocks[lx][y][lz];
        if (b.mesh === currentTarget) {
          parentChunk.blocks[lx][y][lz].exists = false;
          parentChunk.blocks[lx][y][lz].mesh = null;
        }
      }
    }
  }
}

  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);
  removeCrackOverlay(currentTarget);
  currentTarget = null;
  breaking = false;
  updateBreakBar(0);
}

  } else {
    updateBreakBar(0);
  }

  const quat = new THREE.Quaternion().setFromEuler(new THREE.Euler(camPitch, camYaw, 0, 'YXZ'));
  camOffset.applyQuaternion(quat);

  camera.position.copy(player.position).add(camOffset);
  camera.rotation.set(camPitch, camYaw, 0, 'YXZ');
} 
else {
  // 3ra y 2da persona
  const target = player.position.clone();
  target.y += 1;

  let offset;
  if (camMode === 1) {
    // 3ra persona (detr√°s)
    offset = new THREE.Vector3(0, 2, -3);

  } else {
    // 2da persona (diagonal frontal)
    // M√°s lejos y un poco m√°s alto
offset = new THREE.Vector3(0, 2, -3);


  }

  offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), camPitch);
  offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), camYaw);

  const idealCamPos = player.position.clone().add(offset);

  const rayDir = idealCamPos.clone().sub(target).normalize();
  const raycaster = new THREE.Raycaster(target, rayDir, 0, offset.length());

  const intersects = raycaster.intersectObjects(terrain, false);

  if (intersects.length > 0) {
    camera.position.lerp(intersects[0].point, 0.2);
  } else {
    camera.position.lerp(idealCamPos, 0.2);
  }

  camera.lookAt(target);

  player.rotation.y = camMode === 2 ? camYaw + Math.PI : camYaw;
}


  dibujarDebugColisiones();

  renderer.render(scene, camera);
}

updateChunksAroundPlayer();
setInterval(updateChunksAroundPlayer, 1000); // actualiza cada segundo
animate();



</script>

</body>
</html>
