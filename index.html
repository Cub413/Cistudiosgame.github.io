<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bloxd.io + C√°mara 1ra/3ra persona + Mira + Salto corregido</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
<style>
  body { margin: 0; overflow: hidden;
  font-family: 'Press Start 2P', cursive;touch-action: none; background:#87CEEB; }
  

 #joystick {
  position: absolute; bottom: 30px; left: 30px;
  width: 100px; height: 100px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid #888;
  image-rendering: pixelated;
}

  #joystick > div {
    position: absolute;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.7);
    
    pointer-events: none;
    left: 35px;
    top: 35px;
  }
 #pause-button {
  position: absolute;
  top: 1px;
  left: 50%;
  transform: translateX(-50%);
  width: 30px;
  height: 30px;
  background-color: #222;
  color: #fff;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#shadow-toggle {
  position: absolute;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  width: 140px;
  height: 40px;
  background-color: #444;
  color: white;
  font-size: 14px;
  text-align: center;
  line-height: 40px;
  
  z-index: 20;
  cursor: pointer;
}
#shadow-toggle.on {
  background-color: #27ae60;
}

#pause-menu {
  position: absolute;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  backdrop-filter: blur(10px);
  background-color: rgba(0,0,0,0.4);
  z-index: 30;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.pause-option {
  width: 160px;
  margin: 10px;
  padding: 12px;
  background: #333;
  color: white;
  font-size: 18px;
  text-align: center;
  border-radius: 8px;
  cursor: pointer;
}
#collision-toggle.on {
  background-color: #27ae60 !important;
}

#jump-button {
  position: absolute;
  bottom: 59px;
  right: 50px;
  width: 34px;
  height: 34px;
  background-color: #3c3c3c;
  border: 4px solid #fff;
  box-shadow: inset -4px -4px 0 #1a1a1a, inset 4px 4px 0 #666;
  image-rendering: pixelated;
  cursor: pointer;
  border-radius: 0%;
  user-select: none;
  touch-action: none;
  z-index: 10;
}

#camera-toggle {
position: absolute;
top: 10px;
right: 10px;
width: 50px;
height: 40px;
background-color: #222;
color: #e0e0e0;
font-size: 9px;
font-weight: 600;
text-align: center;
line-height: 40px;

box-shadow: 0 2px 5px rgba(0,0,0,0.4);
user-select: none;
cursor: pointer;
transition: background-color 0.25s ease, color 0.25s ease;
z-index: 10;
}
#camera-toggle\:hover {
background: #666;
color: #fff;
}
#camera-toggle\:active {
background: #444;
color: #ccc;
}

  #crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin-left: -10px;
  margin-top: -10px;
  pointer-events: none;
  z-index: 15;
}
#crosshair:before, #crosshair:after {
  content: '';
  position: absolute;
  background: rgba(0, 0, 0, 0.5); /* negro semi-transparente */
}
#crosshair:before {
  left: 9px;
  top: 0;
  width: 2px;
  height: 20px;
}
#crosshair:after {
  top: 9px;
  left: 0;
  width: 20px;
  height: 2px;
}

  #pri-button {
  position: absolute;
  top: 100px;
  right: 10px;
  width: 64px;
  height: 40px;
  background-color: #800;
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  
  z-index: 10;
  user-select: none;
  touch-action: none;
}

  #slide-panel {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: #222;
  color: white;
  padding: 20px;
  box-shadow: -3px 0 10px rgba(0,0,0,0.7);
  transition: right 0.3s ease;
  z-index: 50;
  display: flex;
  flex-direction: column;
}

#slide-panel.open {
  right: 0;
}

#close-panel-btn {
  align-self: flex-end;
  font-size: 24px;
  cursor: pointer;
  user-select: none;
}
#start-panel {
  position: fixed;
  inset: 0;
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#play-button {
  font-family: 'Press Start 2P', monospace;
  font-size: 16px;
  padding: 16px 32px;
  border: 3px solid #fff;
  background-color: #222;
  color: #0f0;
  cursor: pointer;
  box-shadow: 0 0 5px #0f0;
  image-rendering: pixelated;
  text-shadow: 1px 1px 0 #000;
}

#play-button:active {
  transform: scale(0.95);
}

/* Fuente pixel */
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
</style>
</head>
<body>
  <div id="start-panel">
  <button id="play-button">JUGAR</button>
</div>
<div id="break-bar-container" style="position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 5px; border: 2px solid white; display: none;">
  <div id="break-bar" style="background: white; width: 0%; height: 100%;"></div>
</div>

<div id="pause-button"><i class="fas fa-pause"></i></div>


<div id="pause-menu">
  <div class="pause-option" id="resume-btn"><i class="fas fa-play"></i> Reanudar</div>
<div id="open-panel-btn" class="pause-option"><i class="fas fa-cog"></i> Ajustes</div>


<div id="slide-panel">
  <div id="close-panel-btn">√ó</div>
  <!-- Contenido del panel -->

    <div id="shadow-toggle">Sombras: OFF</div>
</div>



 

  <div id="settings-menu" style="display:none; flex-direction: column; align-items: center; justify-content: center; height: 100vh; width: 100vw; position: absolute; top: 0; left: 0; backdrop-filter: blur(10px); background-color: rgba(0,0,0,0.4); z-index: 40;">
  <div class="pause-option" id="back-btn">üîô Volver</div>
  <!-- Aqu√≠ luego agregas tus controles de ajustes -->
</div>

</div>

<div id="joystick"><div id="joystick-thumb"></div></div>
<div id="jump-button"></div>
<div id="camera-toggle">3ra </div>
<div id="pri-button">pri</div>

<div id="crosshair"></div>

<script>
// Setup b√°sico
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Funci√≥n para redimensionar correctamente
function resizeCanvas() {
  const width = window.innerWidth;
  const height = window.innerHeight;
  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
}

// Eventos para detectar rotaci√≥n o cambio de tama√±o
window.addEventListener('resize', resizeCanvas);
screen.orientation?.addEventListener("change", resizeCanvas);
document.addEventListener("fullscreenchange", resizeCanvas);

// Llamar al inicio por si ya est√° en horizontal
resizeCanvas();


document.body.appendChild(renderer.domElement);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const cameraHolder = new THREE.Object3D();
scene.add(cameraHolder);
cameraHolder.add(camera);

const loader = new THREE.TextureLoader();
loader.load('Texturas/dia.jpg', function(texture) {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
});

// Luz
scene.background = new THREE.Color(0xffffff);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(10,20,10);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
scene.add(dirLight);

const salto = 1; // altura de salto en bloques
const gravedadBase = 0.02;
const gravedad = gravedadBase * salto;  // mayor salto = m√°s gravedad para mantener tiempos similares

const texturaGrieta = loader.load('/Texturas/crack.png');
texturaGrieta.wrapS = THREE.RepeatWrapping;
texturaGrieta.wrapT = THREE.RepeatWrapping;


// Terreno b√°sico con bloques
const simplex = new SimplexNoise();
const blockSize = 1;
const worldSize = 10;
let terrain = [];
let joystickTouchId = null;
let cameraTouchId = null;

const textureLoader = new THREE.TextureLoader();
const texturesCrack = [
  textureLoader.load('Texturas/crack1.png'),
  textureLoader.load('Texturas/crack2.png'),
  textureLoader.load('Texturas/crack3.png'),
  textureLoader.load('Texturas/crack4.png'),
  textureLoader.load('Texturas/crack5.png'),
];

const textures = {
  grass_top: textureLoader.load("Texturas/cesped.jpg"),
  grass_side: textureLoader.load("Texturas/cesped_parte_costado.jpg"),
  dirt: textureLoader.load("Texturas/tierra.jpg"),
  stone: textureLoader.load("Texturas/piedra.jpg"),
  crack: textureLoader.load("Texturas/crack.png") // ‚Üê se a√±adi√≥ aqu√≠
};
const panel = document.getElementById("start-panel");
const button = document.getElementById("play-button");

async function goFullscreenLandscape() {
  try {
    // Fullscreen
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    
    // Orientaci√≥n horizontal
    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientaci√≥n:", e);
  }
  async function goFullscreenLandscape() {
  try {
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();

    if (screen.orientation?.lock)
      await screen.orientation.lock("landscape");

    resizeCanvas(); // Asegura que se actualice al instante
  } catch (e) {
    console.warn("No se pudo activar fullscreen u orientaci√≥n:", e);
  }

  panel.style.display = "none";
}

  // Ocultar panel
  panel.style.display = "none";
}

// Mostrar el panel si se sali√≥ de fullscreen u orientaci√≥n
function checkState() {
  const isFull = !!document.fullscreenElement;
  const isLandscape = screen.orientation?.type?.includes("landscape");
  
  if (!isFull || !isLandscape) {
    panel.style.display = "flex";
  }
}

button.addEventListener("click", goFullscreenLandscape);
document.addEventListener("fullscreenchange", checkState);
screen.orientation?.addEventListener("change", checkState);

// Tambi√©n se comprueba al rotar el dispositivo
window.addEventListener("resize", checkState);
const jumpButton = document.getElementById("jump-button");

function createBlock(x, y, z, type) {
  const textureMaps = (() => {
    if(type === "grass") {
      return [
        textures.grass_side,
        textures.grass_side,
        textures.grass_top,
        textures.dirt,
        textures.grass_side,
        textures.grass_side
      ];
    } else if(type === "dirt") {
      return new Array(6).fill(textures.dirt);
    } else if(type === "stone") {
      return new Array(6).fill(textures.stone);
    }
  })();

  const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
  const materials = [];

  for(let i = 0; i < 6; i++) {
    materials.push(new THREE.MeshStandardMaterial({ map: textureMaps[i] }));
  }

  const block = new THREE.Mesh(geometry, materials);

  block.userData = {
    type: type,
    resistance: type === "stone" ? 3 : type === "dirt" ? 1.5 : 1,
    currentBreak: 0,
    crackMaterial: null
  };

  block.castShadow = true;
  block.receiveShadow = true;
  block.position.set(x * blockSize, y * blockSize, z * blockSize);

  scene.add(block);
  terrain.push(block);
}
function actualizarVisibilidadGlobal() {
  const dirs = [
    new THREE.Vector3(1, 0, 0),
    new THREE.Vector3(-1, 0, 0),
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0, -1, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(0, 0, -1),
  ];

  for (const bloque of terrain) {
    const pos = bloque.position.clone().divideScalar(blockSize);

    const estaRodeado = dirs.every(dir => {
      const neighborPos = pos.clone().add(dir);
      return terrain.some(b =>
        b.position.x === neighborPos.x * blockSize &&
        b.position.y === neighborPos.y * blockSize &&
        b.position.z === neighborPos.z * blockSize
      );
    });

    bloque.visible = !estaRodeado;
  }
}

function generateTerrain() {
  terrain = [];
  for(let x = 0; x < worldSize; x++) {
    for(let z = 0; z < worldSize; z++) {
      const n = simplex.noise2D(x / 10, z / 10);
      const h = Math.floor((n + 1) * 5);
      for(let y = 0; y < h; y++) {
        if(y === h - 1) createBlock(x, y, z, "grass");
        else if(y >= h - 3) createBlock(x, y, z, "dirt");
        else createBlock(x, y, z, "stone");
      }
    }
  }
}
setInterval(actualizarVisibilidadGlobal, 100);

// Geometr√≠a y dimensiones del jugador
const playerGeometry = new THREE.BoxGeometry(0.7, 0.9, 0.7);
const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const player = new THREE.Mesh(playerGeometry, playerMaterial);
player.castShadow = true;
player.receiveShadow = true;
scene.add(player);
scene.add(player);



const raycaster = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);
function hayEspacioParaSaltar() {
  const start = player.position.clone().add(new THREE.Vector3(0, 0.5, 0));
  const dir = new THREE.Vector3(0, 1, 0);
  raycaster.ray.origin.copy(start);
  raycaster.ray.direction.copy(dir);

  const intersects = raycaster.intersectObjects(terrain, false);
  for (const hit of intersects) {
    if (hit.distance <= 0.9) return false; // solo bloquea si el obst√°culo est√° a 1.1 o menos
  }

  return true;
}
// L√≠neas de colisi√≥n y raycaster
const debugLines = [];
function dibujarDebugColisiones() {
  debugLines.forEach(line => scene.remove(line));
  debugLines.length = 0;

  if (!mostrarColisiones) return;

  const offsets = [
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0.3, 0, 0),
    new THREE.Vector3(-0.3, 0, 0),
    new THREE.Vector3(0, 0, 0.3),
    new THREE.Vector3(0, 0, -0.3)
  ];

  for (let offset of offsets) {
    const start = player.position.clone().add(offset).setY(player.position.y);
    const end = start.clone();
    end.y -= 3;

    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
    const material = new THREE.LineBasicMaterial({ color: 0xff00ff });
    const line = new THREE.Line(geometry, material);
    scene.add(line);
    debugLines.push(line);
  }

  const rayStart = new THREE.Vector3(player.position.x, 50, player.position.z);
  const rayEnd = rayStart.clone().add(down.clone().multiplyScalar(50));
  const rayGeom = new THREE.BufferGeometry().setFromPoints([rayStart, rayEnd]);
  const rayLine = new THREE.Line(rayGeom, new THREE.LineBasicMaterial({ color: 0xffff00 }));
  scene.add(rayLine);
  debugLines.push(rayLine);
}

function getGroundHeight(x, z) {
  raycaster.ray.origin.set(x, player.position.y + 1, z); // o +1.5 para margen
  raycaster.ray.direction.copy(down);
  const hits = raycaster.intersectObjects(terrain);
  if (hits.length > 0) return hits[0].point.y;
  return 0;
}


player.position.set(worldSize/2,10,worldSize/2);
player.position.y = getGroundHeight(player.position.x, player.position.z)+0.5;
const pauseBtn = document.getElementById("pause-button");
const pauseMenu = document.getElementById("pause-menu");
const resumeBtn = document.getElementById("resume-btn");

let sombrasActivas = false; // Estado inicial: desactivadas

const shadowToggle = document.getElementById("shadow-toggle");
const updateSombras = () => {
  dirLight.castShadow = sombrasActivas;

  scene.traverse(obj => {
    if (obj.isMesh) {
      obj.castShadow = sombrasActivas;
      obj.receiveShadow = sombrasActivas;
    }
  });

  shadowToggle.textContent = sombrasActivas ? "Sombras: ON" : "Sombras: OFF";
  shadowToggle.classList.toggle("on", sombrasActivas);
};
const openBtn = document.getElementById('open-panel-btn');
const slidePanel = document.getElementById('slide-panel');
const closeBtn = document.getElementById('close-panel-btn');

openBtn.addEventListener('click', () => {
  slidePanel.classList.add('open');
});

closeBtn.addEventListener('click', () => {
  slidePanel.classList.remove('open');
});


const showDebugBtn = document.createElement('div');
showDebugBtn.id = 'collision-toggle';
showDebugBtn.textContent = 'Colisiones: OFF';
showDebugBtn.style.position = 'absolute';
showDebugBtn.style.top = '140px';
showDebugBtn.style.left = '50%';
showDebugBtn.style.transform = 'translateX(-50%)';
showDebugBtn.style.width = '180px';
showDebugBtn.style.height = '40px';
showDebugBtn.style.backgroundColor = '#444'; // Se sobreescribe por .on
showDebugBtn.style.color = 'white';
showDebugBtn.style.fontSize = '14px';
showDebugBtn.style.textAlign = 'center';
showDebugBtn.style.lineHeight = '40px';
showDebugBtn.style.zIndex = '20';
showDebugBtn.style.cursor = 'pointer';

let colisionesActivas = false;

showDebugBtn.onclick = () => {
  colisionesActivas = !colisionesActivas;
  showDebugBtn.textContent = colisionesActivas ? "Colisiones: ON" : "Colisiones: OFF";
  showDebugBtn.classList.toggle("on", colisionesActivas);
};

slidePanel.appendChild(showDebugBtn);


let mostrarColisiones = false;
showDebugBtn.addEventListener('click', () => {
  mostrarColisiones = !mostrarColisiones;
  showDebugBtn.textContent = mostrarColisiones ? 'Colisiones: ON' : 'Colisiones: OFF';
  // aqu√≠ llamar√≠as a la funci√≥n que muestra/oculta las colisiones
});

// Palanca
shadowToggle.addEventListener("click", () => {
  sombrasActivas = !sombrasActivas;
  updateSombras();
});

// Aplicar sombras al iniciar (est√°n apagadas)
updateSombras();

let paused = false;

pauseBtn.addEventListener("click", () => {
  paused = true;
  pauseMenu.style.display = "flex";
});

resumeBtn.addEventListener("click", () => {
  paused = false;
  pauseMenu.style.display = "none";
});




// Variables para joystick
const joystick = document.getElementById("joystick");
const thumb = joystick.children[0];
let joystickActive = false;
let joystickStart = {x:0,y:0};
let moveVector = new THREE.Vector2(0,0);

joystick.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (joystickTouchId === null) {
      joystickTouchId = touch.identifier;
      joystickActive = true;
      joystickStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId && joystickActive) {
      const deltaX = (touch.clientX - joystickStart.x) / 50;
      const deltaY = (touch.clientY - joystickStart.y) / 50;
      moveVector.set(
        Math.max(-1, Math.min(1, deltaX)),
        Math.max(-1, Math.min(1, deltaY))
      );
      thumb.style.left = 35 + moveVector.x * 30 + "px";
      thumb.style.top  = 35 + moveVector.y * 30 + "px";
      e.preventDefault();
      break;
    }
  }
});

joystick.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      joystickTouchId = null;
      joystickActive = false;
      moveVector.set(0, 0);
      thumb.style.left = "35px";
      thumb.style.top  = "35px";
      e.preventDefault();
      break;
    }
  }
});

// Variables para control de c√°mara con swipe
let camYaw = 0;
let camPitch = 0;
const camDistance = 5;
let looking = false;
let lookStart = {x:0,y:0};

function isTouchOnJoystick(touch){
  const r = joystick.getBoundingClientRect();
  return (touch.clientX>=r.left && touch.clientX<=r.right && touch.clientY>=r.top && touch.clientY<=r.bottom);
}

renderer.domElement.addEventListener("touchstart", e => {
  for (const touch of e.changedTouches) {
    if (!isTouchOnJoystick(touch) && cameraTouchId === null) {

      cameraTouchId = touch.identifier;
      looking = true;
      lookStart = { x: touch.clientX, y: touch.clientY };
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchmove", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId && looking) {
      if (isTouchOnJoystick(touch)) return;
      const dx = touch.clientX - lookStart.x;
      const dy = touch.clientY - lookStart.y;
      lookStart.x = touch.clientX;
      lookStart.y = touch.clientY;
      camYaw   -= dx * 0.005;
      camPitch -= dy * 0.005;
      const maxP = Math.PI / 2 - 0.1;
      const minP = -maxP;
      camPitch = Math.max(minP, Math.min(maxP, camPitch));
      e.preventDefault();
      break;
    }
  }
});

renderer.domElement.addEventListener("touchend", e => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === cameraTouchId) {
      cameraTouchId = null;
      looking = false;
      e.preventDefault();
      break;
    }
  }
});

const jumpSpeed = 0.23;
let velocityY = 0;
let onGround = false;
let jumpPressed = false;


function jump(){
  if (onGround && hayEspacioParaSaltar()) {
    velocityY = jumpSpeed;
    onGround = false;
  }
}

jumpButton.addEventListener("touchstart", e=>{
  e.preventDefault();
  jumpPressed = true;
  jump();
});
jumpButton.addEventListener("touchend", e=>{
  e.preventDefault();
  jumpPressed = false;
});

// C√°mara toggle 1ra/3ra persona
const camToggleBtn = document.getElementById("camera-toggle");
let firstPerson = false;
camToggleBtn.addEventListener("click", () => {
  firstPerson = !firstPerson;
  camToggleBtn.textContent = firstPerson ? "1ra" : "3ra";
  player.visible = !firstPerson;
});

// Funci√≥n animaci√≥n y l√≥gica
const moveSpeed = 0.3;
const priButton = document.getElementById("pri-button");

let breaking = false;
let currentTarget = null;
let breakStartTime = 0;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const intersects = raycaster.intersectObjects(terrain);
  if (intersects.length > 0) {
    currentTarget = intersects[0].object;
    breakStartTime = performance.now();
    breaking = true;
  }
});

priButton.addEventListener("touchend", () => {
  breaking = false;
  if (currentTarget) {
    removeCrackOverlay(currentTarget);
    currentTarget.userData.currentBreak = 0;
    currentTarget = null;
  }
});

function addCrackLayer(block, index) {
  if (block.userData.crackOverlay) {
    block.userData.crackOverlay.material.map = texturesCrack[index];
    block.userData.crackOverlay.material.needsUpdate = true;
    return;
  }

  const crackTexture = texturesCrack[index];

  const crackMaterial = new THREE.MeshBasicMaterial({
    map: crackTexture,
    transparent: true,
    depthTest: true,
    depthWrite: false,
  });

  const crackMesh = new THREE.Mesh(block.geometry.clone(), crackMaterial);
  crackMesh.position.set(0, 0, 0); // relativo al bloque
  crackMesh.rotation.set(0, 0, 0);
  crackMesh.scale.set(1, 1, 1);
  crackMesh.renderOrder = 999;

  block.add(crackMesh);
  block.userData.crackOverlay = crackMesh;
}

function updateCrackLayer(block, progress) {
  const index = Math.min(Math.floor(progress * texturesCrack.length), texturesCrack.length - 1);

  if (!block.userData.crackOverlay) {
    addCrackLayer(block, index);
  } else {
    block.userData.crackOverlay.material.map = texturesCrack[index];
    block.userData.crackOverlay.material.needsUpdate = true;
  }
}

function removeCrackOverlay(block) {
  const overlay = block.userData.crackOverlay;
  if (overlay) {
    block.remove(overlay);
    if (overlay.geometry) {
      overlay.geometry.dispose();
      overlay.geometry = null;
    }
    if (overlay.material) {
      overlay.material.dispose();
      overlay.material = null;
    }
    block.userData.crackOverlay = null;
  }
  // (resto igual)
}

const maxBreakDistance = 6;

priButton.addEventListener("touchstart", () => {
  raycaster.setFromCamera({x: 0, y: 0}, camera);
  const intersects = raycaster.intersectObjects(terrain);
  if (intersects.length > 0) {
    const target = intersects[0].object;
    const distance = camera.position.distanceTo(target.position);
    if (distance <= maxBreakDistance) {
      currentTarget = target;
      breakStartTime = performance.now();
      breaking = true;
    }
  }
});

function animate() {
  requestAnimationFrame(animate);
  const enableStepUp = false;
const breakBarContainer = document.getElementById('break-bar-container');
const breakBar = document.getElementById('break-bar');

function updateBreakBar(progress) {
  if (progress > 0 && progress < 1) {
    breakBarContainer.style.display = 'block';
    breakBar.style.width = (progress * 100) + '%';
  } else {
    breakBarContainer.style.display = 'none';
    breakBar.style.width = '0%';
  }
}

  // Movimiento relativo a la c√°mara
  if (moveVector.lengthSq() > 0.01) {
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();

    const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

    const moveDir = new THREE.Vector3();
    moveDir.addScaledVector(camDir, -moveVector.y);
    moveDir.addScaledVector(camRight, moveVector.x);
    moveDir.normalize();

    const moveStep = moveDir.clone().multiplyScalar(moveSpeed);

    const playerRadius = 0.3;
const playerHeight = 0.9;

    const stepHeight = 0.1;

    // üëá NUEVO: deslizamiento por separado en X y Z
    const moveX = new THREE.Vector3(moveStep.x, 0, 0);
    const moveZ = new THREE.Vector3(0, 0, moveStep.z);

    const yOffsets = [0, 0.4, 0.8];


    let canMoveX = true;
    let canMoveZ = true;

    // Comprobar colisi√≥n en X
    for (let yOffset of yOffsets) {
      const pos = player.position.clone().add(moveX);
      pos.y += yOffset;

      const offsets = [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ];

      let collision = false;
      for (let offset of offsets) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.5) {
          collision = true;
        }
      }
      if (collision) canMoveX = false;
    }

    // Comprobar colisi√≥n en Z
    for (let yOffset of yOffsets) {
      const pos = player.position.clone().add(moveZ);
      pos.y += yOffset;

      const offsets = [
        new THREE.Vector2(0, 0),
        new THREE.Vector2(playerRadius, 0),
        new THREE.Vector2(-playerRadius, 0),
        new THREE.Vector2(0, playerRadius),
        new THREE.Vector2(0, -playerRadius)
      ];

      let collision = false;
      for (let offset of offsets) {
        const testX = pos.x + offset.x;
        const testZ = pos.z + offset.y;
        const groundY = getGroundHeight(testX, testZ);

        if (pos.y < groundY + 0.5) {
          collision = true;
        }
      }
      if (collision) canMoveZ = false;
    }

    // Aplicar movimiento permitido para lograr deslizamiento
    if (canMoveX) player.position.x += moveStep.x;
    if (canMoveZ) player.position.z += moveStep.z;

    // --- El c√≥digo siguiente que hab√≠as puesto para stepUp y dem√°s queda comentado
    // porque us√°s enableStepUp = false, si lo necesit√°s activo avisame ---
  }

  if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const distance = camera.position.distanceTo(currentTarget.position);
  if (distance > maxBreakDistance) {
    breaking = false;
    removeCrackOverlay(currentTarget);
    currentTarget.userData.currentBreak = 0;
    currentTarget = null;
    updateBreakBar(0);
  } else {
    const delta = 0.016;
    const data = currentTarget.userData;
    data.currentBreak += delta;
    const progress = data.currentBreak / data.resistance;

    updateBreakBar(progress);
    updateCrackLayer(currentTarget, progress); // üëà aplicar textura encima

    if (progress >= 1) {
  removeCrackOverlay(currentTarget); // ‚úÖ eliminar overlay antes
  scene.remove(currentTarget);
  const idx = terrain.indexOf(currentTarget);
  if (idx !== -1) terrain.splice(idx, 1);
  currentTarget = null;
  breaking = false;
  updateBreakBar(0);
}
}
} else {
  updateBreakBar(0);
}

function limpiarCracksFlotantes() {
  for (const bloque of terrain) {
    const overlay = bloque.userData.crackOverlay;
    if (overlay) {
      // Si el bloque fue eliminado o la grieta no coincide con el bloque
      const posicionIgual = overlay.position.equals(bloque.position);
      if (!scene.children.includes(bloque) || !posicionIgual) {
        removeCrackOverlay(bloque);
      }
    }
  }
}

  // Gravedad y salto
  const groundCheckOffsets = [
    new THREE.Vector2(0, 0),
    new THREE.Vector2(0.3, 0),
    new THREE.Vector2(-0.3, 0),
    new THREE.Vector2(0, 0.3),
    new THREE.Vector2(0, -0.3)
  ];

  let ground = -Infinity;
  for (let offset of groundCheckOffsets) {
    const gx = player.position.x + offset.x;
    const gz = player.position.z + offset.y;
    const h = getGroundHeight(gx, gz);
    if (h > ground) ground = h;
  }

  const jumpMax = ground + 0.5 + salto;

  if ((player.position.y < jumpMax && velocityY > 0) || player.position.y > ground + 0.5) {
    velocityY -= gravedad;
    onGround = false;
  } else {
    if (player.position.y >= jumpMax) {
      velocityY = Math.min(velocityY, 0);
      player.position.y = jumpMax;
    } else {
      velocityY = 0;
      player.position.y = ground + 0.5;
      onGround = true;
    }
  }

  player.position.y += velocityY;

  if (firstPerson) {
    const eyeOffset = new THREE.Vector3(0, 0., 0); // altura de los ojos
    const camOffset = eyeOffset.clone();
if (breaking && currentTarget && terrain.includes(currentTarget)) {
  const delta = 0.016; // tiempo entre frames (aprox 60fps)
  const data = currentTarget.userData;
  data.currentBreak += delta;

  const progress = data.currentBreak / data.resistance;
  updateBreakBar(progress); // Actualizar barra de rompimiento

  if (data.currentBreak >= data.resistance) {
    scene.remove(currentTarget);
    const idx = terrain.indexOf(currentTarget);
    if (idx !== -1) terrain.splice(idx, 1);
    currentTarget = null;
    breaking = false;
    updateBreakBar(0); // Ocultar barra al romper bloque
  }
} else {
  updateBreakBar(0); // Ocultar barra si no est√° rompiendo
}

    // Aplicar rotaci√≥n de la c√°mara manualmente
    const quat = new THREE.Quaternion()
      .setFromEuler(new THREE.Euler(camPitch, camYaw, 0, 'YXZ'));
    camOffset.applyQuaternion(quat);

    camera.position.copy(player.position).add(camOffset);
    camera.rotation.set(camPitch, camYaw, 0, 'YXZ');
  } else {
    // C√°mara detr√°s del jugador
    const offset = new THREE.Vector3(0, 1.5, camDistance);
    offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), camPitch);
    offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), camYaw);

    const camPos = player.position.clone().add(offset);
    camera.position.lerp(camPos, 0.2);

    const target = player.position.clone();
    target.y += 1;
    camera.lookAt(target);

    // Girar jugador con la c√°mara
    player.rotation.y = camYaw;
  }

  dibujarDebugColisiones();

  renderer.render(scene, camera);
}

generateTerrain();
animate();


</script>

</body>
</html>
